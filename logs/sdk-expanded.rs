#![feature(prelude_import)]
//!  Main Rust Application for BL602 Firmware
#![no_std]
#[prelude_import]
use core::prelude::rust_2018::*;
#[macro_use]
extern crate core;
#[macro_use]
extern crate compiler_builtins;
//  Use the Rust Core Library instead of the Rust Standard Library, which is not compatible with embedded systems

use bl602_macros::safe_wrap;
use result::*;

//  Include the BL602 Wrappers generated by `bindgen` and `safe_wrap`
#[allow(non_camel_case_types)]
#[allow(non_snake_case)]
pub mod i2c {




    //  Import the Rust Core Library
    //  For `PanicInfo` type used by `panic` function
    //  For converting `str` to `String`

    //  Don't mangle the name `rust_main`
    //  Declare `extern "C"` because it will be called by BL602 firmware
    //  Command line (char *)
    //  Length of command line (int)
    //  Number of command line args (int)
    //  Array of command line args (char **)
    //  Show a message on the serial console

    //  PineCone Blue LED is connected on BL602 GPIO 11
    //  `u8` is 8-bit unsigned integer

    //  Configure the LED GPIO for output (instead of input)
    //  No pullup, no pulldown
    //  Halt on error

    //  Blink the LED 5 times
    //  Iterates 10 times from 0 to 9 (`..` excludes 10)

    //  Toggle the LED GPIO between 0 (on) and 1 (off)
    //  Set the GPIO output (from BL602 GPIO HAL)
    //  GPIO pin number
    //  0 for low, 1 for high
    //  Halt on error

    //  Sleep 1 second
    //  Sleep by number of ticks (from NimBLE Porting Layer)
    //  Convert 1,000 milliseconds to ticks (from NimBLE Porting Layer)

    //  Return to the BL602 command-line interface

    //  `!` means that panic handler will never return
    //  TODO: Implement the complete panic handler like this:
    //  https://github.com/lupyuen/pinetime-rust-BL602/blob/master/rust/app/src/lib.rs#L115-L146

    //  For now we display a message

    //  Loop forever, do not pass go, do not collect $200

    ///////////////////////////////////////////////////////////////////////////////
    //  Safe Wrappers for BL602 C Functions imported from
    //  BL602 IoT SDK and NimBLE Porting Layer
    //  (Will be auto-generated by `bindgen` and Rust Procedural Macro)

    //  `&str` is a reference to a string slice, similar to `const char *` in C

    //  Import C Function

    //  Convert `str` to `String`, which similar to `char [64]` in C
    //  `mut` because we will modify it
    //  If it exceeds 64 chars, halt with an error

    //  Terminate the string with null, since we will be passing to C
    //  If we exceed 64 chars, halt with an error

    //  Convert the null-terminated string to a pointer

    //  Call the C function
    //  Flag this code as unsafe because we're calling a C function

    //  No semicolon `;` here, so the value returned by the C function will be passed to our caller

    //  Number of milliseconds
    //  Returns the number of ticks (uint32_t)
    //  Import C Function

    //  Call the C function
    //  Flag this code as unsafe because we're calling a C function

    //  No semicolon `;` here, so the value returned by the C function will be passed to our caller

    //  Number of ticks to sleep
    //  Import C Function

    //  Call the C function
    //  Flag this code as unsafe because we're calling a C function


    ///////////////////////////////////////////////////////////////////////////////
    //  BL602 Types



    //  Allow type names to have non-camel case




    //  TODO

    use super::*;
    pub const I2C_M_READ: u32 = 1;
    pub const I2C_M_WRITE: u32 = 0;
    pub const I2C_M_BLOCK: u32 = 0;
    pub const I2C_M_NO_BLOCK: u32 = 1;
    pub type __uint8_t = ::cty::c_uchar;
    pub type __uint16_t = ::cty::c_ushort;
    pub type __uint32_t = ::cty::c_uint;
    #[repr(C)]
    pub struct i2c_msg {
        pub addr: u16,
        pub direct: u8,
        pub subflag: u8,
        pub subaddr: u32,
        pub sublen: u8,
        pub len: u32,
        pub buf: *mut u8,
        pub event: ::cty::c_int,
        pub idex: ::cty::c_int,
        pub block: ::cty::c_int,
        pub stop: ::cty::c_int,
        pub ins_num: ::cty::c_int,
        pub i2cx: ::cty::c_int,
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::marker::Copy for i2c_msg { }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::clone::Clone for i2c_msg {
        #[inline]
        fn clone(&self) -> i2c_msg {
            {
                let _: ::core::clone::AssertParamIsClone<u16>;
                let _: ::core::clone::AssertParamIsClone<u8>;
                let _: ::core::clone::AssertParamIsClone<u8>;
                let _: ::core::clone::AssertParamIsClone<u32>;
                let _: ::core::clone::AssertParamIsClone<u8>;
                let _: ::core::clone::AssertParamIsClone<u32>;
                let _: ::core::clone::AssertParamIsClone<*mut u8>;
                let _: ::core::clone::AssertParamIsClone<::cty::c_int>;
                let _: ::core::clone::AssertParamIsClone<::cty::c_int>;
                let _: ::core::clone::AssertParamIsClone<::cty::c_int>;
                let _: ::core::clone::AssertParamIsClone<::cty::c_int>;
                let _: ::core::clone::AssertParamIsClone<::cty::c_int>;
                let _: ::core::clone::AssertParamIsClone<::cty::c_int>;
                *self
            }
        }
    }
    impl Default for i2c_msg {
        fn default() -> Self { unsafe { ::core::mem::zeroed() } }
    }
    pub type i2c_msg_t = i2c_msg;
    pub fn set_freq(freq: ::cty::c_int, i2cx: ::cty::c_int) -> BlResult<()> {
        "----------Extern Decl----------";
        extern "C" {
            pub fn i2c_set_freq(freq: ::cty::c_int, i2cx: ::cty::c_int);
        }
        "----------Validation----------";
        unsafe {
            "----------Call----------";
            i2c_set_freq(freq as ::cty::c_int, i2cx as ::cty::c_int);
            "----------Result----------";
            Ok(())
        }
    }
    pub fn gpio_init(i2cx: ::cty::c_int) -> BlResult<()> {
        "----------Extern Decl----------";
        extern "C" {
            pub fn i2c_gpio_init(i2cx: ::cty::c_int);
        }
        "----------Validation----------";
        unsafe {
            "----------Call----------";
            i2c_gpio_init(i2cx as ::cty::c_int);
            "----------Result----------";
            Ok(())
        }
    }
    pub fn clear_status(i2cx: ::cty::c_int) -> BlResult<()> {
        "----------Extern Decl----------";
        extern "C" {
            pub fn i2c_clear_status(i2cx: ::cty::c_int);
        }
        "----------Validation----------";
        unsafe {
            "----------Call----------";
            i2c_clear_status(i2cx as ::cty::c_int);
            "----------Result----------";
            Ok(())
        }
    }
    pub fn transfer_start(pstmsg: *mut i2c_msg_t) -> BlResult<()> {
        "----------Extern Decl----------";
        extern "C" {
            pub fn i2c_transfer_start(pstmsg: *mut i2c_msg_t);
        }
        "----------Validation----------";
        unsafe {
            "----------Call----------";
            i2c_transfer_start(pstmsg as *mut i2c_msg_t);
            "----------Result----------";
            Ok(())
        }
    }
}
#[allow(non_camel_case_types)]
#[allow(non_snake_case)]
pub mod gpio {
    use super::*;
    pub type __uint8_t = ::cty::c_uchar;
    #[repr(C)]
    pub struct _gpio_ctx_desc {
        pub next: *mut _gpio_ctx_desc,
        pub gpio_handler: ::core::option::Option<unsafe extern "C" fn(arg1:
                                                                          *mut ::cty::c_void)>,
        pub arg: *mut ::cty::c_void,
        pub gpioPin: u8,
        pub intCtrlMod: u8,
        pub intTrgMod: u8,
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::marker::Copy for _gpio_ctx_desc { }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::clone::Clone for _gpio_ctx_desc {
        #[inline]
        fn clone(&self) -> _gpio_ctx_desc {
            {
                let _: ::core::clone::AssertParamIsClone<*mut _gpio_ctx_desc>;
                let _:
                        ::core::clone::AssertParamIsClone<::core::option::Option<unsafe extern "C" fn(arg1:
                                                                                                          *mut ::cty::c_void)>>;
                let _: ::core::clone::AssertParamIsClone<*mut ::cty::c_void>;
                let _: ::core::clone::AssertParamIsClone<u8>;
                let _: ::core::clone::AssertParamIsClone<u8>;
                let _: ::core::clone::AssertParamIsClone<u8>;
                *self
            }
        }
    }
    impl Default for _gpio_ctx_desc {
        fn default() -> Self { unsafe { ::core::mem::zeroed() } }
    }
    pub type gpio_ctx_t = _gpio_ctx_desc;
    pub fn gpio_enable_output(pin: u8, pullup: u8, pulldown: u8)
     -> BlResult<()> {
        "----------Extern Decl----------";
        extern "C" {
            pub fn bl_gpio_enable_output(pin: u8, pullup: u8, pulldown: u8)
            -> ::cty::c_int;
        }
        "----------Validation----------";
        unsafe {
            "----------Call----------";
            let res =
                bl_gpio_enable_output(pin as u8, pullup as u8,
                                      pulldown as u8);
            "----------Result----------";
            match res { 0 => Ok(()), _ => Err(BlError::from(res)), }
        }
    }
    pub fn gpio_enable_input(pin: u8, pullup: u8, pulldown: u8)
     -> BlResult<()> {
        "----------Extern Decl----------";
        extern "C" {
            pub fn bl_gpio_enable_input(pin: u8, pullup: u8, pulldown: u8)
            -> ::cty::c_int;
        }
        "----------Validation----------";
        unsafe {
            "----------Call----------";
            let res =
                bl_gpio_enable_input(pin as u8, pullup as u8, pulldown as u8);
            "----------Result----------";
            match res { 0 => Ok(()), _ => Err(BlError::from(res)), }
        }
    }
    pub fn gpio_output_set(pin: u8, value: u8) -> BlResult<()> {
        "----------Extern Decl----------";
        extern "C" {
            pub fn bl_gpio_output_set(pin: u8, value: u8)
            -> ::cty::c_int;
        }
        "----------Validation----------";
        unsafe {
            "----------Call----------";
            let res = bl_gpio_output_set(pin as u8, value as u8);
            "----------Result----------";
            match res { 0 => Ok(()), _ => Err(BlError::from(res)), }
        }
    }
    pub fn gpio_input_get(pin: u8, value: *mut u8) -> BlResult<()> {
        "----------Extern Decl----------";
        extern "C" {
            pub fn bl_gpio_input_get(pin: u8, value: *mut u8)
            -> ::cty::c_int;
        }
        "----------Validation----------";
        unsafe {
            "----------Call----------";
            let res = bl_gpio_input_get(pin as u8, value as *mut u8);
            "----------Result----------";
            match res { 0 => Ok(()), _ => Err(BlError::from(res)), }
        }
    }
    pub fn gpio_input_get_value(pin: u8) -> BlResult<()> {
        "----------Extern Decl----------";
        extern "C" {
            pub fn bl_gpio_input_get_value(pin: u8)
            -> ::cty::c_int;
        }
        "----------Validation----------";
        unsafe {
            "----------Call----------";
            let res = bl_gpio_input_get_value(pin as u8);
            "----------Result----------";
            match res { 0 => Ok(()), _ => Err(BlError::from(res)), }
        }
    }
    pub fn gpio_int_clear(gpioPin: u8, intClear: u8) -> BlResult<()> {
        "----------Extern Decl----------";
        extern "C" {
            pub fn bl_gpio_int_clear(gpioPin: u8, intClear: u8)
            -> ::cty::c_int;
        }
        "----------Validation----------";
        unsafe {
            "----------Call----------";
            let res = bl_gpio_int_clear(gpioPin as u8, intClear as u8);
            "----------Result----------";
            match res { 0 => Ok(()), _ => Err(BlError::from(res)), }
        }
    }
    pub fn gpio_intmask(gpiopin: u8, mask: u8) -> BlResult<()> {
        "----------Extern Decl----------";
        extern "C" {
            pub fn bl_gpio_intmask(gpiopin: u8, mask: u8);
        }
        "----------Validation----------";
        unsafe {
            "----------Call----------";
            bl_gpio_intmask(gpiopin as u8, mask as u8);
            "----------Result----------";
            Ok(())
        }
    }
    pub fn gpio_register(pstnode: *mut gpio_ctx_t) -> BlResult<()> {
        "----------Extern Decl----------";
        extern "C" {
            pub fn bl_gpio_register(pstnode: *mut gpio_ctx_t);
        }
        "----------Validation----------";
        unsafe {
            "----------Call----------";
            bl_gpio_register(pstnode as *mut gpio_ctx_t);
            "----------Result----------";
            Ok(())
        }
    }
}
#[allow(non_camel_case_types)]
#[allow(non_snake_case)]
#[allow(non_upper_case_globals)]
pub mod pwm {
    use super::*;
    #[repr(C)]
    pub struct __BindgenBitfieldUnit<Storage> {
        storage: Storage,
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl <Storage: ::core::marker::Copy> ::core::marker::Copy for
     __BindgenBitfieldUnit<Storage> {
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl <Storage: ::core::clone::Clone> ::core::clone::Clone for
     __BindgenBitfieldUnit<Storage> {
        #[inline]
        fn clone(&self) -> __BindgenBitfieldUnit<Storage> {
            match *self {
                __BindgenBitfieldUnit { storage: ref __self_0_0 } =>
                __BindgenBitfieldUnit{storage:
                                          ::core::clone::Clone::clone(&(*__self_0_0)),},
            }
        }
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl <Storage: ::core::fmt::Debug> ::core::fmt::Debug for
     __BindgenBitfieldUnit<Storage> {
        fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {
            match *self {
                __BindgenBitfieldUnit { storage: ref __self_0_0 } => {
                    let debug_trait_builder =
                        &mut ::core::fmt::Formatter::debug_struct(f,
                                                                  "__BindgenBitfieldUnit");
                    let _ =
                        ::core::fmt::DebugStruct::field(debug_trait_builder,
                                                        "storage",
                                                        &&(*__self_0_0));
                    ::core::fmt::DebugStruct::finish(debug_trait_builder)
                }
            }
        }
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl <Storage: ::core::default::Default> ::core::default::Default for
     __BindgenBitfieldUnit<Storage> {
        #[inline]
        fn default() -> __BindgenBitfieldUnit<Storage> {
            __BindgenBitfieldUnit{storage:
                                      ::core::default::Default::default(),}
        }
    }
    impl <Storage> ::core::marker::StructuralEq for
     __BindgenBitfieldUnit<Storage> {
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl <Storage: ::core::cmp::Eq> ::core::cmp::Eq for
     __BindgenBitfieldUnit<Storage> {
        #[inline]
        #[doc(hidden)]
        #[no_coverage]
        fn assert_receiver_is_total_eq(&self) -> () {
            { let _: ::core::cmp::AssertParamIsEq<Storage>; }
        }
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl <Storage: ::core::hash::Hash> ::core::hash::Hash for
     __BindgenBitfieldUnit<Storage> {
        fn hash<__H: ::core::hash::Hasher>(&self, state: &mut __H) -> () {
            match *self {
                __BindgenBitfieldUnit { storage: ref __self_0_0 } => {
                    ::core::hash::Hash::hash(&(*__self_0_0), state)
                }
            }
        }
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl <Storage: ::core::cmp::Ord> ::core::cmp::Ord for
     __BindgenBitfieldUnit<Storage> {
        #[inline]
        fn cmp(&self, other: &__BindgenBitfieldUnit<Storage>)
         -> ::core::cmp::Ordering {
            match *other {
                __BindgenBitfieldUnit { storage: ref __self_1_0 } =>
                match *self {
                    __BindgenBitfieldUnit { storage: ref __self_0_0 } =>
                    match ::core::cmp::Ord::cmp(&(*__self_0_0),
                                                &(*__self_1_0)) {
                        ::core::cmp::Ordering::Equal =>
                        ::core::cmp::Ordering::Equal,
                        cmp => cmp,
                    },
                },
            }
        }
    }
    impl <Storage> ::core::marker::StructuralPartialEq for
     __BindgenBitfieldUnit<Storage> {
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl <Storage: ::core::cmp::PartialEq> ::core::cmp::PartialEq for
     __BindgenBitfieldUnit<Storage> {
        #[inline]
        fn eq(&self, other: &__BindgenBitfieldUnit<Storage>) -> bool {
            match *other {
                __BindgenBitfieldUnit { storage: ref __self_1_0 } =>
                match *self {
                    __BindgenBitfieldUnit { storage: ref __self_0_0 } =>
                    (*__self_0_0) == (*__self_1_0),
                },
            }
        }
        #[inline]
        fn ne(&self, other: &__BindgenBitfieldUnit<Storage>) -> bool {
            match *other {
                __BindgenBitfieldUnit { storage: ref __self_1_0 } =>
                match *self {
                    __BindgenBitfieldUnit { storage: ref __self_0_0 } =>
                    (*__self_0_0) != (*__self_1_0),
                },
            }
        }
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl <Storage: ::core::cmp::PartialOrd> ::core::cmp::PartialOrd for
     __BindgenBitfieldUnit<Storage> {
        #[inline]
        fn partial_cmp(&self, other: &__BindgenBitfieldUnit<Storage>)
         -> ::core::option::Option<::core::cmp::Ordering> {
            match *other {
                __BindgenBitfieldUnit { storage: ref __self_1_0 } =>
                match *self {
                    __BindgenBitfieldUnit { storage: ref __self_0_0 } =>
                    match ::core::cmp::PartialOrd::partial_cmp(&(*__self_0_0),
                                                               &(*__self_1_0))
                        {
                        ::core::option::Option::Some(::core::cmp::Ordering::Equal)
                        =>
                        ::core::option::Option::Some(::core::cmp::Ordering::Equal),
                        cmp => cmp,
                    },
                },
            }
        }
    }
    impl <Storage> __BindgenBitfieldUnit<Storage> {
        #[inline]
        pub const fn new(storage: Storage) -> Self { Self{storage,} }
    }
    impl <Storage> __BindgenBitfieldUnit<Storage> where Storage: AsRef<[u8]> +
     AsMut<[u8]> {
        #[inline]
        pub fn get_bit(&self, index: usize) -> bool {
            if true {
                if !(index / 8 < self.storage.as_ref().len()) {
                    ::core::panicking::panic("assertion failed: index / 8 < self.storage.as_ref().len()")
                };
            };
            let byte_index = index / 8;
            let byte = self.storage.as_ref()[byte_index];
            let bit_index = if false { 7 - (index % 8) } else { index % 8 };
            let mask = 1 << bit_index;
            byte & mask == mask
        }
        #[inline]
        pub fn set_bit(&mut self, index: usize, val: bool) {
            if true {
                if !(index / 8 < self.storage.as_ref().len()) {
                    ::core::panicking::panic("assertion failed: index / 8 < self.storage.as_ref().len()")
                };
            };
            let byte_index = index / 8;
            let byte = &mut self.storage.as_mut()[byte_index];
            let bit_index = if false { 7 - (index % 8) } else { index % 8 };
            let mask = 1 << bit_index;
            if val { *byte |= mask; } else { *byte &= !mask; }
        }
        #[inline]
        pub fn get(&self, bit_offset: usize, bit_width: u8) -> u64 {
            if true {
                if !(bit_width <= 64) {
                    ::core::panicking::panic("assertion failed: bit_width <= 64")
                };
            };
            if true {
                if !(bit_offset / 8 < self.storage.as_ref().len()) {
                    ::core::panicking::panic("assertion failed: bit_offset / 8 < self.storage.as_ref().len()")
                };
            };
            if true {
                if !((bit_offset + (bit_width as usize)) / 8 <=
                         self.storage.as_ref().len()) {
                    ::core::panicking::panic("assertion failed: (bit_offset + (bit_width as usize)) / 8 <= self.storage.as_ref().len()")
                };
            };
            let mut val = 0;
            for i in 0..(bit_width as usize) {
                if self.get_bit(i + bit_offset) {
                    let index =
                        if false { bit_width as usize - 1 - i } else { i };
                    val |= 1 << index;
                }
            }
            val
        }
        #[inline]
        pub fn set(&mut self, bit_offset: usize, bit_width: u8, val: u64) {
            if true {
                if !(bit_width <= 64) {
                    ::core::panicking::panic("assertion failed: bit_width <= 64")
                };
            };
            if true {
                if !(bit_offset / 8 < self.storage.as_ref().len()) {
                    ::core::panicking::panic("assertion failed: bit_offset / 8 < self.storage.as_ref().len()")
                };
            };
            if true {
                if !((bit_offset + (bit_width as usize)) / 8 <=
                         self.storage.as_ref().len()) {
                    ::core::panicking::panic("assertion failed: (bit_offset + (bit_width as usize)) / 8 <= self.storage.as_ref().len()")
                };
            };
            for i in 0..(bit_width as usize) {
                let mask = 1 << i;
                let val_bit_is_set = val & mask == mask;
                let index =
                    if false { bit_width as usize - 1 - i } else { i };
                self.set_bit(index + bit_offset, val_bit_is_set);
            }
        }
    }
    pub const PWM_INT_CONFIG_OFFSET: u32 = 0;
    pub const PWM_INTERRUPT_STS_POS: u32 = 0;
    pub const PWM_INTERRUPT_STS_LEN: u32 = 6;
    pub const PWM_INTERRUPT_STS_MSK: u32 = 63;
    pub const PWM_INTERRUPT_STS_UMSK: i32 = -64;
    pub const PWM_INT_CLEAR_POS: u32 = 8;
    pub const PWM_INT_CLEAR_LEN: u32 = 6;
    pub const PWM_INT_CLEAR_MSK: u32 = 16128;
    pub const PWM_INT_CLEAR_UMSK: i32 = -16129;
    pub const PWM0_CLKDIV_OFFSET: u32 = 32;
    pub const PWM_CLK_DIV_POS: u32 = 0;
    pub const PWM_CLK_DIV_LEN: u32 = 16;
    pub const PWM_CLK_DIV_MSK: u32 = 65535;
    pub const PWM_CLK_DIV_UMSK: i32 = -65536;
    pub const PWM0_THRE1_OFFSET: u32 = 36;
    pub const PWM_THRE1_POS: u32 = 0;
    pub const PWM_THRE1_LEN: u32 = 16;
    pub const PWM_THRE1_MSK: u32 = 65535;
    pub const PWM_THRE1_UMSK: i32 = -65536;
    pub const PWM0_THRE2_OFFSET: u32 = 40;
    pub const PWM_THRE2_POS: u32 = 0;
    pub const PWM_THRE2_LEN: u32 = 16;
    pub const PWM_THRE2_MSK: u32 = 65535;
    pub const PWM_THRE2_UMSK: i32 = -65536;
    pub const PWM0_PERIOD_OFFSET: u32 = 44;
    pub const PWM_PERIOD_POS: u32 = 0;
    pub const PWM_PERIOD_LEN: u32 = 16;
    pub const PWM_PERIOD_MSK: u32 = 65535;
    pub const PWM_PERIOD_UMSK: i32 = -65536;
    pub const PWM0_CONFIG_OFFSET: u32 = 48;
    pub const PWM_REG_CLK_SEL_POS: u32 = 0;
    pub const PWM_REG_CLK_SEL_LEN: u32 = 2;
    pub const PWM_REG_CLK_SEL_MSK: u32 = 3;
    pub const PWM_REG_CLK_SEL_UMSK: i32 = -4;
    pub const PWM_OUT_INV_POS: u32 = 2;
    pub const PWM_OUT_INV_LEN: u32 = 1;
    pub const PWM_OUT_INV_MSK: u32 = 4;
    pub const PWM_OUT_INV_UMSK: i32 = -5;
    pub const PWM_STOP_MODE_POS: u32 = 3;
    pub const PWM_STOP_MODE_LEN: u32 = 1;
    pub const PWM_STOP_MODE_MSK: u32 = 8;
    pub const PWM_STOP_MODE_UMSK: i32 = -9;
    pub const PWM_SW_FORCE_VAL_POS: u32 = 4;
    pub const PWM_SW_FORCE_VAL_LEN: u32 = 1;
    pub const PWM_SW_FORCE_VAL_MSK: u32 = 16;
    pub const PWM_SW_FORCE_VAL_UMSK: i32 = -17;
    pub const PWM_SW_MODE_POS: u32 = 5;
    pub const PWM_SW_MODE_LEN: u32 = 1;
    pub const PWM_SW_MODE_MSK: u32 = 32;
    pub const PWM_SW_MODE_UMSK: i32 = -33;
    pub const PWM_STOP_EN_POS: u32 = 6;
    pub const PWM_STOP_EN_LEN: u32 = 1;
    pub const PWM_STOP_EN_MSK: u32 = 64;
    pub const PWM_STOP_EN_UMSK: i32 = -65;
    pub const PWM_STS_TOP_POS: u32 = 7;
    pub const PWM_STS_TOP_LEN: u32 = 1;
    pub const PWM_STS_TOP_MSK: u32 = 128;
    pub const PWM_STS_TOP_UMSK: i32 = -129;
    pub const PWM0_INTERRUPT_OFFSET: u32 = 52;
    pub const PWM_INT_PERIOD_CNT_POS: u32 = 0;
    pub const PWM_INT_PERIOD_CNT_LEN: u32 = 16;
    pub const PWM_INT_PERIOD_CNT_MSK: u32 = 65535;
    pub const PWM_INT_PERIOD_CNT_UMSK: i32 = -65536;
    pub const PWM_INT_ENABLE_POS: u32 = 16;
    pub const PWM_INT_ENABLE_LEN: u32 = 1;
    pub const PWM_INT_ENABLE_MSK: u32 = 65536;
    pub const PWM_INT_ENABLE_UMSK: i32 = -65537;
    pub const PWM1_CLKDIV_OFFSET: u32 = 64;
    pub const PWM1_THRE1_OFFSET: u32 = 68;
    pub const PWM1_THRE2_OFFSET: u32 = 72;
    pub const PWM1_PERIOD_OFFSET: u32 = 76;
    pub const PWM1_CONFIG_OFFSET: u32 = 80;
    pub const PWM1_INTERRUPT_OFFSET: u32 = 84;
    pub const PWM2_CLKDIV_OFFSET: u32 = 96;
    pub const PWM2_THRE1_OFFSET: u32 = 100;
    pub const PWM2_THRE2_OFFSET: u32 = 104;
    pub const PWM2_PERIOD_OFFSET: u32 = 108;
    pub const PWM2_CONFIG_OFFSET: u32 = 112;
    pub const PWM2_INTERRUPT_OFFSET: u32 = 116;
    pub const PWM3_CLKDIV_OFFSET: u32 = 128;
    pub const PWM3_THRE1_OFFSET: u32 = 132;
    pub const PWM3_THRE2_OFFSET: u32 = 136;
    pub const PWM3_PERIOD_OFFSET: u32 = 140;
    pub const PWM3_CONFIG_OFFSET: u32 = 144;
    pub const PWM3_INTERRUPT_OFFSET: u32 = 148;
    pub const PWM4_CLKDIV_OFFSET: u32 = 160;
    pub const PWM4_THRE1_OFFSET: u32 = 164;
    pub const PWM4_THRE2_OFFSET: u32 = 168;
    pub const PWM4_PERIOD_OFFSET: u32 = 172;
    pub const PWM4_CONFIG_OFFSET: u32 = 176;
    pub const PWM4_INTERRUPT_OFFSET: u32 = 180;
    pub const PWM_CLKDIV_OFFSET: u32 = 0;
    pub const PWM_THRE1_OFFSET: u32 = 4;
    pub const PWM_THRE2_OFFSET: u32 = 8;
    pub const PWM_PERIOD_OFFSET: u32 = 12;
    pub const PWM_CONFIG_OFFSET: u32 = 16;
    pub const PWM_INTERRUPT_OFFSET: u32 = 20;
    pub const PWM_CHANNEL_OFFSET: u32 = 32;
    pub const BL_PWM_XTAL_CLK: u32 = 40000000;
    pub const BL_PWM_BUS_BCLK: u32 = 80000000;
    pub const BL_PWM_CLK: u32 = 40000000;
    pub type __uint8_t = ::cty::c_uchar;
    pub type __uint16_t = ::cty::c_ushort;
    pub type __int32_t = ::cty::c_int;
    pub type __uint32_t = ::cty::c_uint;
    #[repr(C)]
    pub struct pwm_reg {
        pub pwm_int_config: pwm_reg__bindgen_ty_1,
        pub RESERVED0x4: [u8; 28usize],
        pub pwm0_clkdiv: pwm_reg__bindgen_ty_2,
        pub pwm0_thre1: pwm_reg__bindgen_ty_3,
        pub pwm0_thre2: pwm_reg__bindgen_ty_4,
        pub pwm0_period: pwm_reg__bindgen_ty_5,
        pub pwm0_config: pwm_reg__bindgen_ty_6,
        pub pwm0_interrupt: pwm_reg__bindgen_ty_7,
        pub RESERVED0x38: [u8; 8usize],
        pub pwm1_clkdiv: pwm_reg__bindgen_ty_8,
        pub pwm1_thre1: pwm_reg__bindgen_ty_9,
        pub pwm1_thre2: pwm_reg__bindgen_ty_10,
        pub pwm1_period: pwm_reg__bindgen_ty_11,
        pub pwm1_config: pwm_reg__bindgen_ty_12,
        pub pwm1_interrupt: pwm_reg__bindgen_ty_13,
        pub RESERVED0x58: [u8; 8usize],
        pub pwm2_clkdiv: pwm_reg__bindgen_ty_14,
        pub pwm2_thre1: pwm_reg__bindgen_ty_15,
        pub pwm2_thre2: pwm_reg__bindgen_ty_16,
        pub pwm2_period: pwm_reg__bindgen_ty_17,
        pub pwm2_config: pwm_reg__bindgen_ty_18,
        pub pwm2_interrupt: pwm_reg__bindgen_ty_19,
        pub RESERVED0x78: [u8; 8usize],
        pub pwm3_clkdiv: pwm_reg__bindgen_ty_20,
        pub pwm3_thre1: pwm_reg__bindgen_ty_21,
        pub pwm3_thre2: pwm_reg__bindgen_ty_22,
        pub pwm3_period: pwm_reg__bindgen_ty_23,
        pub pwm3_config: pwm_reg__bindgen_ty_24,
        pub pwm3_interrupt: pwm_reg__bindgen_ty_25,
        pub RESERVED0x98: [u8; 8usize],
        pub pwm4_clkdiv: pwm_reg__bindgen_ty_26,
        pub pwm4_thre1: pwm_reg__bindgen_ty_27,
        pub pwm4_thre2: pwm_reg__bindgen_ty_28,
        pub pwm4_period: pwm_reg__bindgen_ty_29,
        pub pwm4_config: pwm_reg__bindgen_ty_30,
        pub pwm4_interrupt: pwm_reg__bindgen_ty_31,
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::marker::Copy for pwm_reg { }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::clone::Clone for pwm_reg {
        #[inline]
        fn clone(&self) -> pwm_reg {
            {
                let _:
                        ::core::clone::AssertParamIsClone<pwm_reg__bindgen_ty_1>;
                let _: ::core::clone::AssertParamIsClone<[u8; 28usize]>;
                let _:
                        ::core::clone::AssertParamIsClone<pwm_reg__bindgen_ty_2>;
                let _:
                        ::core::clone::AssertParamIsClone<pwm_reg__bindgen_ty_3>;
                let _:
                        ::core::clone::AssertParamIsClone<pwm_reg__bindgen_ty_4>;
                let _:
                        ::core::clone::AssertParamIsClone<pwm_reg__bindgen_ty_5>;
                let _:
                        ::core::clone::AssertParamIsClone<pwm_reg__bindgen_ty_6>;
                let _:
                        ::core::clone::AssertParamIsClone<pwm_reg__bindgen_ty_7>;
                let _: ::core::clone::AssertParamIsClone<[u8; 8usize]>;
                let _:
                        ::core::clone::AssertParamIsClone<pwm_reg__bindgen_ty_8>;
                let _:
                        ::core::clone::AssertParamIsClone<pwm_reg__bindgen_ty_9>;
                let _:
                        ::core::clone::AssertParamIsClone<pwm_reg__bindgen_ty_10>;
                let _:
                        ::core::clone::AssertParamIsClone<pwm_reg__bindgen_ty_11>;
                let _:
                        ::core::clone::AssertParamIsClone<pwm_reg__bindgen_ty_12>;
                let _:
                        ::core::clone::AssertParamIsClone<pwm_reg__bindgen_ty_13>;
                let _: ::core::clone::AssertParamIsClone<[u8; 8usize]>;
                let _:
                        ::core::clone::AssertParamIsClone<pwm_reg__bindgen_ty_14>;
                let _:
                        ::core::clone::AssertParamIsClone<pwm_reg__bindgen_ty_15>;
                let _:
                        ::core::clone::AssertParamIsClone<pwm_reg__bindgen_ty_16>;
                let _:
                        ::core::clone::AssertParamIsClone<pwm_reg__bindgen_ty_17>;
                let _:
                        ::core::clone::AssertParamIsClone<pwm_reg__bindgen_ty_18>;
                let _:
                        ::core::clone::AssertParamIsClone<pwm_reg__bindgen_ty_19>;
                let _: ::core::clone::AssertParamIsClone<[u8; 8usize]>;
                let _:
                        ::core::clone::AssertParamIsClone<pwm_reg__bindgen_ty_20>;
                let _:
                        ::core::clone::AssertParamIsClone<pwm_reg__bindgen_ty_21>;
                let _:
                        ::core::clone::AssertParamIsClone<pwm_reg__bindgen_ty_22>;
                let _:
                        ::core::clone::AssertParamIsClone<pwm_reg__bindgen_ty_23>;
                let _:
                        ::core::clone::AssertParamIsClone<pwm_reg__bindgen_ty_24>;
                let _:
                        ::core::clone::AssertParamIsClone<pwm_reg__bindgen_ty_25>;
                let _: ::core::clone::AssertParamIsClone<[u8; 8usize]>;
                let _:
                        ::core::clone::AssertParamIsClone<pwm_reg__bindgen_ty_26>;
                let _:
                        ::core::clone::AssertParamIsClone<pwm_reg__bindgen_ty_27>;
                let _:
                        ::core::clone::AssertParamIsClone<pwm_reg__bindgen_ty_28>;
                let _:
                        ::core::clone::AssertParamIsClone<pwm_reg__bindgen_ty_29>;
                let _:
                        ::core::clone::AssertParamIsClone<pwm_reg__bindgen_ty_30>;
                let _:
                        ::core::clone::AssertParamIsClone<pwm_reg__bindgen_ty_31>;
                *self
            }
        }
    }
    #[repr(C)]
    pub union pwm_reg__bindgen_ty_1 {
        pub BF: pwm_reg__bindgen_ty_1__bindgen_ty_1,
        pub WORD: u32,
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::marker::Copy for pwm_reg__bindgen_ty_1 { }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::clone::Clone for pwm_reg__bindgen_ty_1 {
        #[inline]
        fn clone(&self) -> pwm_reg__bindgen_ty_1 {
            { let _: ::core::clone::AssertParamIsCopy<Self>; *self }
        }
    }
    #[repr(C)]
    #[repr(align(4))]
    pub struct pwm_reg__bindgen_ty_1__bindgen_ty_1 {
        pub _bitfield_align_1: [u32; 0],
        pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::default::Default for pwm_reg__bindgen_ty_1__bindgen_ty_1 {
        #[inline]
        fn default() -> pwm_reg__bindgen_ty_1__bindgen_ty_1 {
            pwm_reg__bindgen_ty_1__bindgen_ty_1{_bitfield_align_1:
                                                    ::core::default::Default::default(),
                                                _bitfield_1:
                                                    ::core::default::Default::default(),}
        }
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::marker::Copy for pwm_reg__bindgen_ty_1__bindgen_ty_1 { }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::clone::Clone for pwm_reg__bindgen_ty_1__bindgen_ty_1 {
        #[inline]
        fn clone(&self) -> pwm_reg__bindgen_ty_1__bindgen_ty_1 {
            {
                let _: ::core::clone::AssertParamIsClone<[u32; 0]>;
                let _:
                        ::core::clone::AssertParamIsClone<__BindgenBitfieldUnit<[u8; 4usize]>>;
                *self
            }
        }
    }
    impl pwm_reg__bindgen_ty_1__bindgen_ty_1 {
        #[inline]
        pub fn pwm_interrupt_sts(&self) -> u32 {
            unsafe {
                ::core::mem::transmute(self._bitfield_1.get(0usize, 6u8) as
                                           u32)
            }
        }
        #[inline]
        pub fn set_pwm_interrupt_sts(&mut self, val: u32) {
            unsafe {
                let val: u32 = ::core::mem::transmute(val);
                self._bitfield_1.set(0usize, 6u8, val as u64)
            }
        }
        #[inline]
        pub fn reserved_6_7(&self) -> u32 {
            unsafe {
                ::core::mem::transmute(self._bitfield_1.get(6usize, 2u8) as
                                           u32)
            }
        }
        #[inline]
        pub fn set_reserved_6_7(&mut self, val: u32) {
            unsafe {
                let val: u32 = ::core::mem::transmute(val);
                self._bitfield_1.set(6usize, 2u8, val as u64)
            }
        }
        #[inline]
        pub fn pwm_int_clear(&self) -> u32 {
            unsafe {
                ::core::mem::transmute(self._bitfield_1.get(8usize, 6u8) as
                                           u32)
            }
        }
        #[inline]
        pub fn set_pwm_int_clear(&mut self, val: u32) {
            unsafe {
                let val: u32 = ::core::mem::transmute(val);
                self._bitfield_1.set(8usize, 6u8, val as u64)
            }
        }
        #[inline]
        pub fn reserved_14_31(&self) -> u32 {
            unsafe {
                ::core::mem::transmute(self._bitfield_1.get(14usize, 18u8) as
                                           u32)
            }
        }
        #[inline]
        pub fn set_reserved_14_31(&mut self, val: u32) {
            unsafe {
                let val: u32 = ::core::mem::transmute(val);
                self._bitfield_1.set(14usize, 18u8, val as u64)
            }
        }
        #[inline]
        pub fn new_bitfield_1(pwm_interrupt_sts: u32, reserved_6_7: u32,
                              pwm_int_clear: u32, reserved_14_31: u32)
         -> __BindgenBitfieldUnit<[u8; 4usize]> {
            let mut __bindgen_bitfield_unit:
                    __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
            __bindgen_bitfield_unit.set(0usize, 6u8,
                                        {
                                            let pwm_interrupt_sts: u32 =
                                                unsafe {
                                                    ::core::mem::transmute(pwm_interrupt_sts)
                                                };
                                            pwm_interrupt_sts as u64
                                        });
            __bindgen_bitfield_unit.set(6usize, 2u8,
                                        {
                                            let reserved_6_7: u32 =
                                                unsafe {
                                                    ::core::mem::transmute(reserved_6_7)
                                                };
                                            reserved_6_7 as u64
                                        });
            __bindgen_bitfield_unit.set(8usize, 6u8,
                                        {
                                            let pwm_int_clear: u32 =
                                                unsafe {
                                                    ::core::mem::transmute(pwm_int_clear)
                                                };
                                            pwm_int_clear as u64
                                        });
            __bindgen_bitfield_unit.set(14usize, 18u8,
                                        {
                                            let reserved_14_31: u32 =
                                                unsafe {
                                                    ::core::mem::transmute(reserved_14_31)
                                                };
                                            reserved_14_31 as u64
                                        });
            __bindgen_bitfield_unit
        }
    }
    impl Default for pwm_reg__bindgen_ty_1 {
        fn default() -> Self { unsafe { ::core::mem::zeroed() } }
    }
    #[repr(C)]
    pub union pwm_reg__bindgen_ty_2 {
        pub BF: pwm_reg__bindgen_ty_2__bindgen_ty_1,
        pub WORD: u32,
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::marker::Copy for pwm_reg__bindgen_ty_2 { }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::clone::Clone for pwm_reg__bindgen_ty_2 {
        #[inline]
        fn clone(&self) -> pwm_reg__bindgen_ty_2 {
            { let _: ::core::clone::AssertParamIsCopy<Self>; *self }
        }
    }
    #[repr(C)]
    #[repr(align(4))]
    pub struct pwm_reg__bindgen_ty_2__bindgen_ty_1 {
        pub _bitfield_align_1: [u16; 0],
        pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::default::Default for pwm_reg__bindgen_ty_2__bindgen_ty_1 {
        #[inline]
        fn default() -> pwm_reg__bindgen_ty_2__bindgen_ty_1 {
            pwm_reg__bindgen_ty_2__bindgen_ty_1{_bitfield_align_1:
                                                    ::core::default::Default::default(),
                                                _bitfield_1:
                                                    ::core::default::Default::default(),}
        }
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::marker::Copy for pwm_reg__bindgen_ty_2__bindgen_ty_1 { }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::clone::Clone for pwm_reg__bindgen_ty_2__bindgen_ty_1 {
        #[inline]
        fn clone(&self) -> pwm_reg__bindgen_ty_2__bindgen_ty_1 {
            {
                let _: ::core::clone::AssertParamIsClone<[u16; 0]>;
                let _:
                        ::core::clone::AssertParamIsClone<__BindgenBitfieldUnit<[u8; 4usize]>>;
                *self
            }
        }
    }
    impl pwm_reg__bindgen_ty_2__bindgen_ty_1 {
        #[inline]
        pub fn pwm_clk_div(&self) -> u32 {
            unsafe {
                ::core::mem::transmute(self._bitfield_1.get(0usize, 16u8) as
                                           u32)
            }
        }
        #[inline]
        pub fn set_pwm_clk_div(&mut self, val: u32) {
            unsafe {
                let val: u32 = ::core::mem::transmute(val);
                self._bitfield_1.set(0usize, 16u8, val as u64)
            }
        }
        #[inline]
        pub fn reserved_16_31(&self) -> u32 {
            unsafe {
                ::core::mem::transmute(self._bitfield_1.get(16usize, 16u8) as
                                           u32)
            }
        }
        #[inline]
        pub fn set_reserved_16_31(&mut self, val: u32) {
            unsafe {
                let val: u32 = ::core::mem::transmute(val);
                self._bitfield_1.set(16usize, 16u8, val as u64)
            }
        }
        #[inline]
        pub fn new_bitfield_1(pwm_clk_div: u32, reserved_16_31: u32)
         -> __BindgenBitfieldUnit<[u8; 4usize]> {
            let mut __bindgen_bitfield_unit:
                    __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
            __bindgen_bitfield_unit.set(0usize, 16u8,
                                        {
                                            let pwm_clk_div: u32 =
                                                unsafe {
                                                    ::core::mem::transmute(pwm_clk_div)
                                                };
                                            pwm_clk_div as u64
                                        });
            __bindgen_bitfield_unit.set(16usize, 16u8,
                                        {
                                            let reserved_16_31: u32 =
                                                unsafe {
                                                    ::core::mem::transmute(reserved_16_31)
                                                };
                                            reserved_16_31 as u64
                                        });
            __bindgen_bitfield_unit
        }
    }
    impl Default for pwm_reg__bindgen_ty_2 {
        fn default() -> Self { unsafe { ::core::mem::zeroed() } }
    }
    #[repr(C)]
    pub union pwm_reg__bindgen_ty_3 {
        pub BF: pwm_reg__bindgen_ty_3__bindgen_ty_1,
        pub WORD: u32,
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::marker::Copy for pwm_reg__bindgen_ty_3 { }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::clone::Clone for pwm_reg__bindgen_ty_3 {
        #[inline]
        fn clone(&self) -> pwm_reg__bindgen_ty_3 {
            { let _: ::core::clone::AssertParamIsCopy<Self>; *self }
        }
    }
    #[repr(C)]
    #[repr(align(4))]
    pub struct pwm_reg__bindgen_ty_3__bindgen_ty_1 {
        pub _bitfield_align_1: [u16; 0],
        pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::default::Default for pwm_reg__bindgen_ty_3__bindgen_ty_1 {
        #[inline]
        fn default() -> pwm_reg__bindgen_ty_3__bindgen_ty_1 {
            pwm_reg__bindgen_ty_3__bindgen_ty_1{_bitfield_align_1:
                                                    ::core::default::Default::default(),
                                                _bitfield_1:
                                                    ::core::default::Default::default(),}
        }
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::marker::Copy for pwm_reg__bindgen_ty_3__bindgen_ty_1 { }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::clone::Clone for pwm_reg__bindgen_ty_3__bindgen_ty_1 {
        #[inline]
        fn clone(&self) -> pwm_reg__bindgen_ty_3__bindgen_ty_1 {
            {
                let _: ::core::clone::AssertParamIsClone<[u16; 0]>;
                let _:
                        ::core::clone::AssertParamIsClone<__BindgenBitfieldUnit<[u8; 4usize]>>;
                *self
            }
        }
    }
    impl pwm_reg__bindgen_ty_3__bindgen_ty_1 {
        #[inline]
        pub fn pwm_thre1(&self) -> u32 {
            unsafe {
                ::core::mem::transmute(self._bitfield_1.get(0usize, 16u8) as
                                           u32)
            }
        }
        #[inline]
        pub fn set_pwm_thre1(&mut self, val: u32) {
            unsafe {
                let val: u32 = ::core::mem::transmute(val);
                self._bitfield_1.set(0usize, 16u8, val as u64)
            }
        }
        #[inline]
        pub fn reserved_16_31(&self) -> u32 {
            unsafe {
                ::core::mem::transmute(self._bitfield_1.get(16usize, 16u8) as
                                           u32)
            }
        }
        #[inline]
        pub fn set_reserved_16_31(&mut self, val: u32) {
            unsafe {
                let val: u32 = ::core::mem::transmute(val);
                self._bitfield_1.set(16usize, 16u8, val as u64)
            }
        }
        #[inline]
        pub fn new_bitfield_1(pwm_thre1: u32, reserved_16_31: u32)
         -> __BindgenBitfieldUnit<[u8; 4usize]> {
            let mut __bindgen_bitfield_unit:
                    __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
            __bindgen_bitfield_unit.set(0usize, 16u8,
                                        {
                                            let pwm_thre1: u32 =
                                                unsafe {
                                                    ::core::mem::transmute(pwm_thre1)
                                                };
                                            pwm_thre1 as u64
                                        });
            __bindgen_bitfield_unit.set(16usize, 16u8,
                                        {
                                            let reserved_16_31: u32 =
                                                unsafe {
                                                    ::core::mem::transmute(reserved_16_31)
                                                };
                                            reserved_16_31 as u64
                                        });
            __bindgen_bitfield_unit
        }
    }
    impl Default for pwm_reg__bindgen_ty_3 {
        fn default() -> Self { unsafe { ::core::mem::zeroed() } }
    }
    #[repr(C)]
    pub union pwm_reg__bindgen_ty_4 {
        pub BF: pwm_reg__bindgen_ty_4__bindgen_ty_1,
        pub WORD: u32,
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::marker::Copy for pwm_reg__bindgen_ty_4 { }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::clone::Clone for pwm_reg__bindgen_ty_4 {
        #[inline]
        fn clone(&self) -> pwm_reg__bindgen_ty_4 {
            { let _: ::core::clone::AssertParamIsCopy<Self>; *self }
        }
    }
    #[repr(C)]
    #[repr(align(4))]
    pub struct pwm_reg__bindgen_ty_4__bindgen_ty_1 {
        pub _bitfield_align_1: [u16; 0],
        pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::default::Default for pwm_reg__bindgen_ty_4__bindgen_ty_1 {
        #[inline]
        fn default() -> pwm_reg__bindgen_ty_4__bindgen_ty_1 {
            pwm_reg__bindgen_ty_4__bindgen_ty_1{_bitfield_align_1:
                                                    ::core::default::Default::default(),
                                                _bitfield_1:
                                                    ::core::default::Default::default(),}
        }
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::marker::Copy for pwm_reg__bindgen_ty_4__bindgen_ty_1 { }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::clone::Clone for pwm_reg__bindgen_ty_4__bindgen_ty_1 {
        #[inline]
        fn clone(&self) -> pwm_reg__bindgen_ty_4__bindgen_ty_1 {
            {
                let _: ::core::clone::AssertParamIsClone<[u16; 0]>;
                let _:
                        ::core::clone::AssertParamIsClone<__BindgenBitfieldUnit<[u8; 4usize]>>;
                *self
            }
        }
    }
    impl pwm_reg__bindgen_ty_4__bindgen_ty_1 {
        #[inline]
        pub fn pwm_thre2(&self) -> u32 {
            unsafe {
                ::core::mem::transmute(self._bitfield_1.get(0usize, 16u8) as
                                           u32)
            }
        }
        #[inline]
        pub fn set_pwm_thre2(&mut self, val: u32) {
            unsafe {
                let val: u32 = ::core::mem::transmute(val);
                self._bitfield_1.set(0usize, 16u8, val as u64)
            }
        }
        #[inline]
        pub fn reserved_16_31(&self) -> u32 {
            unsafe {
                ::core::mem::transmute(self._bitfield_1.get(16usize, 16u8) as
                                           u32)
            }
        }
        #[inline]
        pub fn set_reserved_16_31(&mut self, val: u32) {
            unsafe {
                let val: u32 = ::core::mem::transmute(val);
                self._bitfield_1.set(16usize, 16u8, val as u64)
            }
        }
        #[inline]
        pub fn new_bitfield_1(pwm_thre2: u32, reserved_16_31: u32)
         -> __BindgenBitfieldUnit<[u8; 4usize]> {
            let mut __bindgen_bitfield_unit:
                    __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
            __bindgen_bitfield_unit.set(0usize, 16u8,
                                        {
                                            let pwm_thre2: u32 =
                                                unsafe {
                                                    ::core::mem::transmute(pwm_thre2)
                                                };
                                            pwm_thre2 as u64
                                        });
            __bindgen_bitfield_unit.set(16usize, 16u8,
                                        {
                                            let reserved_16_31: u32 =
                                                unsafe {
                                                    ::core::mem::transmute(reserved_16_31)
                                                };
                                            reserved_16_31 as u64
                                        });
            __bindgen_bitfield_unit
        }
    }
    impl Default for pwm_reg__bindgen_ty_4 {
        fn default() -> Self { unsafe { ::core::mem::zeroed() } }
    }
    #[repr(C)]
    pub union pwm_reg__bindgen_ty_5 {
        pub BF: pwm_reg__bindgen_ty_5__bindgen_ty_1,
        pub WORD: u32,
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::marker::Copy for pwm_reg__bindgen_ty_5 { }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::clone::Clone for pwm_reg__bindgen_ty_5 {
        #[inline]
        fn clone(&self) -> pwm_reg__bindgen_ty_5 {
            { let _: ::core::clone::AssertParamIsCopy<Self>; *self }
        }
    }
    #[repr(C)]
    #[repr(align(4))]
    pub struct pwm_reg__bindgen_ty_5__bindgen_ty_1 {
        pub _bitfield_align_1: [u16; 0],
        pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::default::Default for pwm_reg__bindgen_ty_5__bindgen_ty_1 {
        #[inline]
        fn default() -> pwm_reg__bindgen_ty_5__bindgen_ty_1 {
            pwm_reg__bindgen_ty_5__bindgen_ty_1{_bitfield_align_1:
                                                    ::core::default::Default::default(),
                                                _bitfield_1:
                                                    ::core::default::Default::default(),}
        }
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::marker::Copy for pwm_reg__bindgen_ty_5__bindgen_ty_1 { }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::clone::Clone for pwm_reg__bindgen_ty_5__bindgen_ty_1 {
        #[inline]
        fn clone(&self) -> pwm_reg__bindgen_ty_5__bindgen_ty_1 {
            {
                let _: ::core::clone::AssertParamIsClone<[u16; 0]>;
                let _:
                        ::core::clone::AssertParamIsClone<__BindgenBitfieldUnit<[u8; 4usize]>>;
                *self
            }
        }
    }
    impl pwm_reg__bindgen_ty_5__bindgen_ty_1 {
        #[inline]
        pub fn pwm_period(&self) -> u32 {
            unsafe {
                ::core::mem::transmute(self._bitfield_1.get(0usize, 16u8) as
                                           u32)
            }
        }
        #[inline]
        pub fn set_pwm_period(&mut self, val: u32) {
            unsafe {
                let val: u32 = ::core::mem::transmute(val);
                self._bitfield_1.set(0usize, 16u8, val as u64)
            }
        }
        #[inline]
        pub fn reserved_16_31(&self) -> u32 {
            unsafe {
                ::core::mem::transmute(self._bitfield_1.get(16usize, 16u8) as
                                           u32)
            }
        }
        #[inline]
        pub fn set_reserved_16_31(&mut self, val: u32) {
            unsafe {
                let val: u32 = ::core::mem::transmute(val);
                self._bitfield_1.set(16usize, 16u8, val as u64)
            }
        }
        #[inline]
        pub fn new_bitfield_1(pwm_period: u32, reserved_16_31: u32)
         -> __BindgenBitfieldUnit<[u8; 4usize]> {
            let mut __bindgen_bitfield_unit:
                    __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
            __bindgen_bitfield_unit.set(0usize, 16u8,
                                        {
                                            let pwm_period: u32 =
                                                unsafe {
                                                    ::core::mem::transmute(pwm_period)
                                                };
                                            pwm_period as u64
                                        });
            __bindgen_bitfield_unit.set(16usize, 16u8,
                                        {
                                            let reserved_16_31: u32 =
                                                unsafe {
                                                    ::core::mem::transmute(reserved_16_31)
                                                };
                                            reserved_16_31 as u64
                                        });
            __bindgen_bitfield_unit
        }
    }
    impl Default for pwm_reg__bindgen_ty_5 {
        fn default() -> Self { unsafe { ::core::mem::zeroed() } }
    }
    #[repr(C)]
    pub union pwm_reg__bindgen_ty_6 {
        pub BF: pwm_reg__bindgen_ty_6__bindgen_ty_1,
        pub WORD: u32,
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::marker::Copy for pwm_reg__bindgen_ty_6 { }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::clone::Clone for pwm_reg__bindgen_ty_6 {
        #[inline]
        fn clone(&self) -> pwm_reg__bindgen_ty_6 {
            { let _: ::core::clone::AssertParamIsCopy<Self>; *self }
        }
    }
    #[repr(C)]
    #[repr(align(4))]
    pub struct pwm_reg__bindgen_ty_6__bindgen_ty_1 {
        pub _bitfield_align_1: [u32; 0],
        pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::default::Default for pwm_reg__bindgen_ty_6__bindgen_ty_1 {
        #[inline]
        fn default() -> pwm_reg__bindgen_ty_6__bindgen_ty_1 {
            pwm_reg__bindgen_ty_6__bindgen_ty_1{_bitfield_align_1:
                                                    ::core::default::Default::default(),
                                                _bitfield_1:
                                                    ::core::default::Default::default(),}
        }
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::marker::Copy for pwm_reg__bindgen_ty_6__bindgen_ty_1 { }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::clone::Clone for pwm_reg__bindgen_ty_6__bindgen_ty_1 {
        #[inline]
        fn clone(&self) -> pwm_reg__bindgen_ty_6__bindgen_ty_1 {
            {
                let _: ::core::clone::AssertParamIsClone<[u32; 0]>;
                let _:
                        ::core::clone::AssertParamIsClone<__BindgenBitfieldUnit<[u8; 4usize]>>;
                *self
            }
        }
    }
    impl pwm_reg__bindgen_ty_6__bindgen_ty_1 {
        #[inline]
        pub fn reg_clk_sel(&self) -> u32 {
            unsafe {
                ::core::mem::transmute(self._bitfield_1.get(0usize, 2u8) as
                                           u32)
            }
        }
        #[inline]
        pub fn set_reg_clk_sel(&mut self, val: u32) {
            unsafe {
                let val: u32 = ::core::mem::transmute(val);
                self._bitfield_1.set(0usize, 2u8, val as u64)
            }
        }
        #[inline]
        pub fn pwm_out_inv(&self) -> u32 {
            unsafe {
                ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as
                                           u32)
            }
        }
        #[inline]
        pub fn set_pwm_out_inv(&mut self, val: u32) {
            unsafe {
                let val: u32 = ::core::mem::transmute(val);
                self._bitfield_1.set(2usize, 1u8, val as u64)
            }
        }
        #[inline]
        pub fn pwm_stop_mode(&self) -> u32 {
            unsafe {
                ::core::mem::transmute(self._bitfield_1.get(3usize, 1u8) as
                                           u32)
            }
        }
        #[inline]
        pub fn set_pwm_stop_mode(&mut self, val: u32) {
            unsafe {
                let val: u32 = ::core::mem::transmute(val);
                self._bitfield_1.set(3usize, 1u8, val as u64)
            }
        }
        #[inline]
        pub fn pwm_sw_force_val(&self) -> u32 {
            unsafe {
                ::core::mem::transmute(self._bitfield_1.get(4usize, 1u8) as
                                           u32)
            }
        }
        #[inline]
        pub fn set_pwm_sw_force_val(&mut self, val: u32) {
            unsafe {
                let val: u32 = ::core::mem::transmute(val);
                self._bitfield_1.set(4usize, 1u8, val as u64)
            }
        }
        #[inline]
        pub fn pwm_sw_mode(&self) -> u32 {
            unsafe {
                ::core::mem::transmute(self._bitfield_1.get(5usize, 1u8) as
                                           u32)
            }
        }
        #[inline]
        pub fn set_pwm_sw_mode(&mut self, val: u32) {
            unsafe {
                let val: u32 = ::core::mem::transmute(val);
                self._bitfield_1.set(5usize, 1u8, val as u64)
            }
        }
        #[inline]
        pub fn pwm_stop_en(&self) -> u32 {
            unsafe {
                ::core::mem::transmute(self._bitfield_1.get(6usize, 1u8) as
                                           u32)
            }
        }
        #[inline]
        pub fn set_pwm_stop_en(&mut self, val: u32) {
            unsafe {
                let val: u32 = ::core::mem::transmute(val);
                self._bitfield_1.set(6usize, 1u8, val as u64)
            }
        }
        #[inline]
        pub fn pwm_sts_top(&self) -> u32 {
            unsafe {
                ::core::mem::transmute(self._bitfield_1.get(7usize, 1u8) as
                                           u32)
            }
        }
        #[inline]
        pub fn set_pwm_sts_top(&mut self, val: u32) {
            unsafe {
                let val: u32 = ::core::mem::transmute(val);
                self._bitfield_1.set(7usize, 1u8, val as u64)
            }
        }
        #[inline]
        pub fn reserved_8_31(&self) -> u32 {
            unsafe {
                ::core::mem::transmute(self._bitfield_1.get(8usize, 24u8) as
                                           u32)
            }
        }
        #[inline]
        pub fn set_reserved_8_31(&mut self, val: u32) {
            unsafe {
                let val: u32 = ::core::mem::transmute(val);
                self._bitfield_1.set(8usize, 24u8, val as u64)
            }
        }
        #[inline]
        pub fn new_bitfield_1(reg_clk_sel: u32, pwm_out_inv: u32,
                              pwm_stop_mode: u32, pwm_sw_force_val: u32,
                              pwm_sw_mode: u32, pwm_stop_en: u32,
                              pwm_sts_top: u32, reserved_8_31: u32)
         -> __BindgenBitfieldUnit<[u8; 4usize]> {
            let mut __bindgen_bitfield_unit:
                    __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
            __bindgen_bitfield_unit.set(0usize, 2u8,
                                        {
                                            let reg_clk_sel: u32 =
                                                unsafe {
                                                    ::core::mem::transmute(reg_clk_sel)
                                                };
                                            reg_clk_sel as u64
                                        });
            __bindgen_bitfield_unit.set(2usize, 1u8,
                                        {
                                            let pwm_out_inv: u32 =
                                                unsafe {
                                                    ::core::mem::transmute(pwm_out_inv)
                                                };
                                            pwm_out_inv as u64
                                        });
            __bindgen_bitfield_unit.set(3usize, 1u8,
                                        {
                                            let pwm_stop_mode: u32 =
                                                unsafe {
                                                    ::core::mem::transmute(pwm_stop_mode)
                                                };
                                            pwm_stop_mode as u64
                                        });
            __bindgen_bitfield_unit.set(4usize, 1u8,
                                        {
                                            let pwm_sw_force_val: u32 =
                                                unsafe {
                                                    ::core::mem::transmute(pwm_sw_force_val)
                                                };
                                            pwm_sw_force_val as u64
                                        });
            __bindgen_bitfield_unit.set(5usize, 1u8,
                                        {
                                            let pwm_sw_mode: u32 =
                                                unsafe {
                                                    ::core::mem::transmute(pwm_sw_mode)
                                                };
                                            pwm_sw_mode as u64
                                        });
            __bindgen_bitfield_unit.set(6usize, 1u8,
                                        {
                                            let pwm_stop_en: u32 =
                                                unsafe {
                                                    ::core::mem::transmute(pwm_stop_en)
                                                };
                                            pwm_stop_en as u64
                                        });
            __bindgen_bitfield_unit.set(7usize, 1u8,
                                        {
                                            let pwm_sts_top: u32 =
                                                unsafe {
                                                    ::core::mem::transmute(pwm_sts_top)
                                                };
                                            pwm_sts_top as u64
                                        });
            __bindgen_bitfield_unit.set(8usize, 24u8,
                                        {
                                            let reserved_8_31: u32 =
                                                unsafe {
                                                    ::core::mem::transmute(reserved_8_31)
                                                };
                                            reserved_8_31 as u64
                                        });
            __bindgen_bitfield_unit
        }
    }
    impl Default for pwm_reg__bindgen_ty_6 {
        fn default() -> Self { unsafe { ::core::mem::zeroed() } }
    }
    #[repr(C)]
    pub union pwm_reg__bindgen_ty_7 {
        pub BF: pwm_reg__bindgen_ty_7__bindgen_ty_1,
        pub WORD: u32,
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::marker::Copy for pwm_reg__bindgen_ty_7 { }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::clone::Clone for pwm_reg__bindgen_ty_7 {
        #[inline]
        fn clone(&self) -> pwm_reg__bindgen_ty_7 {
            { let _: ::core::clone::AssertParamIsCopy<Self>; *self }
        }
    }
    #[repr(C)]
    #[repr(align(4))]
    pub struct pwm_reg__bindgen_ty_7__bindgen_ty_1 {
        pub _bitfield_align_1: [u16; 0],
        pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::default::Default for pwm_reg__bindgen_ty_7__bindgen_ty_1 {
        #[inline]
        fn default() -> pwm_reg__bindgen_ty_7__bindgen_ty_1 {
            pwm_reg__bindgen_ty_7__bindgen_ty_1{_bitfield_align_1:
                                                    ::core::default::Default::default(),
                                                _bitfield_1:
                                                    ::core::default::Default::default(),}
        }
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::marker::Copy for pwm_reg__bindgen_ty_7__bindgen_ty_1 { }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::clone::Clone for pwm_reg__bindgen_ty_7__bindgen_ty_1 {
        #[inline]
        fn clone(&self) -> pwm_reg__bindgen_ty_7__bindgen_ty_1 {
            {
                let _: ::core::clone::AssertParamIsClone<[u16; 0]>;
                let _:
                        ::core::clone::AssertParamIsClone<__BindgenBitfieldUnit<[u8; 4usize]>>;
                *self
            }
        }
    }
    impl pwm_reg__bindgen_ty_7__bindgen_ty_1 {
        #[inline]
        pub fn pwm_int_period_cnt(&self) -> u32 {
            unsafe {
                ::core::mem::transmute(self._bitfield_1.get(0usize, 16u8) as
                                           u32)
            }
        }
        #[inline]
        pub fn set_pwm_int_period_cnt(&mut self, val: u32) {
            unsafe {
                let val: u32 = ::core::mem::transmute(val);
                self._bitfield_1.set(0usize, 16u8, val as u64)
            }
        }
        #[inline]
        pub fn pwm_int_enable(&self) -> u32 {
            unsafe {
                ::core::mem::transmute(self._bitfield_1.get(16usize, 1u8) as
                                           u32)
            }
        }
        #[inline]
        pub fn set_pwm_int_enable(&mut self, val: u32) {
            unsafe {
                let val: u32 = ::core::mem::transmute(val);
                self._bitfield_1.set(16usize, 1u8, val as u64)
            }
        }
        #[inline]
        pub fn reserved_17_31(&self) -> u32 {
            unsafe {
                ::core::mem::transmute(self._bitfield_1.get(17usize, 15u8) as
                                           u32)
            }
        }
        #[inline]
        pub fn set_reserved_17_31(&mut self, val: u32) {
            unsafe {
                let val: u32 = ::core::mem::transmute(val);
                self._bitfield_1.set(17usize, 15u8, val as u64)
            }
        }
        #[inline]
        pub fn new_bitfield_1(pwm_int_period_cnt: u32, pwm_int_enable: u32,
                              reserved_17_31: u32)
         -> __BindgenBitfieldUnit<[u8; 4usize]> {
            let mut __bindgen_bitfield_unit:
                    __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
            __bindgen_bitfield_unit.set(0usize, 16u8,
                                        {
                                            let pwm_int_period_cnt: u32 =
                                                unsafe {
                                                    ::core::mem::transmute(pwm_int_period_cnt)
                                                };
                                            pwm_int_period_cnt as u64
                                        });
            __bindgen_bitfield_unit.set(16usize, 1u8,
                                        {
                                            let pwm_int_enable: u32 =
                                                unsafe {
                                                    ::core::mem::transmute(pwm_int_enable)
                                                };
                                            pwm_int_enable as u64
                                        });
            __bindgen_bitfield_unit.set(17usize, 15u8,
                                        {
                                            let reserved_17_31: u32 =
                                                unsafe {
                                                    ::core::mem::transmute(reserved_17_31)
                                                };
                                            reserved_17_31 as u64
                                        });
            __bindgen_bitfield_unit
        }
    }
    impl Default for pwm_reg__bindgen_ty_7 {
        fn default() -> Self { unsafe { ::core::mem::zeroed() } }
    }
    #[repr(C)]
    pub union pwm_reg__bindgen_ty_8 {
        pub BF: pwm_reg__bindgen_ty_8__bindgen_ty_1,
        pub WORD: u32,
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::marker::Copy for pwm_reg__bindgen_ty_8 { }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::clone::Clone for pwm_reg__bindgen_ty_8 {
        #[inline]
        fn clone(&self) -> pwm_reg__bindgen_ty_8 {
            { let _: ::core::clone::AssertParamIsCopy<Self>; *self }
        }
    }
    #[repr(C)]
    #[repr(align(4))]
    pub struct pwm_reg__bindgen_ty_8__bindgen_ty_1 {
        pub _bitfield_align_1: [u16; 0],
        pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::default::Default for pwm_reg__bindgen_ty_8__bindgen_ty_1 {
        #[inline]
        fn default() -> pwm_reg__bindgen_ty_8__bindgen_ty_1 {
            pwm_reg__bindgen_ty_8__bindgen_ty_1{_bitfield_align_1:
                                                    ::core::default::Default::default(),
                                                _bitfield_1:
                                                    ::core::default::Default::default(),}
        }
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::marker::Copy for pwm_reg__bindgen_ty_8__bindgen_ty_1 { }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::clone::Clone for pwm_reg__bindgen_ty_8__bindgen_ty_1 {
        #[inline]
        fn clone(&self) -> pwm_reg__bindgen_ty_8__bindgen_ty_1 {
            {
                let _: ::core::clone::AssertParamIsClone<[u16; 0]>;
                let _:
                        ::core::clone::AssertParamIsClone<__BindgenBitfieldUnit<[u8; 4usize]>>;
                *self
            }
        }
    }
    impl pwm_reg__bindgen_ty_8__bindgen_ty_1 {
        #[inline]
        pub fn pwm_clk_div(&self) -> u32 {
            unsafe {
                ::core::mem::transmute(self._bitfield_1.get(0usize, 16u8) as
                                           u32)
            }
        }
        #[inline]
        pub fn set_pwm_clk_div(&mut self, val: u32) {
            unsafe {
                let val: u32 = ::core::mem::transmute(val);
                self._bitfield_1.set(0usize, 16u8, val as u64)
            }
        }
        #[inline]
        pub fn reserved_16_31(&self) -> u32 {
            unsafe {
                ::core::mem::transmute(self._bitfield_1.get(16usize, 16u8) as
                                           u32)
            }
        }
        #[inline]
        pub fn set_reserved_16_31(&mut self, val: u32) {
            unsafe {
                let val: u32 = ::core::mem::transmute(val);
                self._bitfield_1.set(16usize, 16u8, val as u64)
            }
        }
        #[inline]
        pub fn new_bitfield_1(pwm_clk_div: u32, reserved_16_31: u32)
         -> __BindgenBitfieldUnit<[u8; 4usize]> {
            let mut __bindgen_bitfield_unit:
                    __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
            __bindgen_bitfield_unit.set(0usize, 16u8,
                                        {
                                            let pwm_clk_div: u32 =
                                                unsafe {
                                                    ::core::mem::transmute(pwm_clk_div)
                                                };
                                            pwm_clk_div as u64
                                        });
            __bindgen_bitfield_unit.set(16usize, 16u8,
                                        {
                                            let reserved_16_31: u32 =
                                                unsafe {
                                                    ::core::mem::transmute(reserved_16_31)
                                                };
                                            reserved_16_31 as u64
                                        });
            __bindgen_bitfield_unit
        }
    }
    impl Default for pwm_reg__bindgen_ty_8 {
        fn default() -> Self { unsafe { ::core::mem::zeroed() } }
    }
    #[repr(C)]
    pub union pwm_reg__bindgen_ty_9 {
        pub BF: pwm_reg__bindgen_ty_9__bindgen_ty_1,
        pub WORD: u32,
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::marker::Copy for pwm_reg__bindgen_ty_9 { }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::clone::Clone for pwm_reg__bindgen_ty_9 {
        #[inline]
        fn clone(&self) -> pwm_reg__bindgen_ty_9 {
            { let _: ::core::clone::AssertParamIsCopy<Self>; *self }
        }
    }
    #[repr(C)]
    #[repr(align(4))]
    pub struct pwm_reg__bindgen_ty_9__bindgen_ty_1 {
        pub _bitfield_align_1: [u16; 0],
        pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::default::Default for pwm_reg__bindgen_ty_9__bindgen_ty_1 {
        #[inline]
        fn default() -> pwm_reg__bindgen_ty_9__bindgen_ty_1 {
            pwm_reg__bindgen_ty_9__bindgen_ty_1{_bitfield_align_1:
                                                    ::core::default::Default::default(),
                                                _bitfield_1:
                                                    ::core::default::Default::default(),}
        }
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::marker::Copy for pwm_reg__bindgen_ty_9__bindgen_ty_1 { }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::clone::Clone for pwm_reg__bindgen_ty_9__bindgen_ty_1 {
        #[inline]
        fn clone(&self) -> pwm_reg__bindgen_ty_9__bindgen_ty_1 {
            {
                let _: ::core::clone::AssertParamIsClone<[u16; 0]>;
                let _:
                        ::core::clone::AssertParamIsClone<__BindgenBitfieldUnit<[u8; 4usize]>>;
                *self
            }
        }
    }
    impl pwm_reg__bindgen_ty_9__bindgen_ty_1 {
        #[inline]
        pub fn pwm_thre1(&self) -> u32 {
            unsafe {
                ::core::mem::transmute(self._bitfield_1.get(0usize, 16u8) as
                                           u32)
            }
        }
        #[inline]
        pub fn set_pwm_thre1(&mut self, val: u32) {
            unsafe {
                let val: u32 = ::core::mem::transmute(val);
                self._bitfield_1.set(0usize, 16u8, val as u64)
            }
        }
        #[inline]
        pub fn reserved_16_31(&self) -> u32 {
            unsafe {
                ::core::mem::transmute(self._bitfield_1.get(16usize, 16u8) as
                                           u32)
            }
        }
        #[inline]
        pub fn set_reserved_16_31(&mut self, val: u32) {
            unsafe {
                let val: u32 = ::core::mem::transmute(val);
                self._bitfield_1.set(16usize, 16u8, val as u64)
            }
        }
        #[inline]
        pub fn new_bitfield_1(pwm_thre1: u32, reserved_16_31: u32)
         -> __BindgenBitfieldUnit<[u8; 4usize]> {
            let mut __bindgen_bitfield_unit:
                    __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
            __bindgen_bitfield_unit.set(0usize, 16u8,
                                        {
                                            let pwm_thre1: u32 =
                                                unsafe {
                                                    ::core::mem::transmute(pwm_thre1)
                                                };
                                            pwm_thre1 as u64
                                        });
            __bindgen_bitfield_unit.set(16usize, 16u8,
                                        {
                                            let reserved_16_31: u32 =
                                                unsafe {
                                                    ::core::mem::transmute(reserved_16_31)
                                                };
                                            reserved_16_31 as u64
                                        });
            __bindgen_bitfield_unit
        }
    }
    impl Default for pwm_reg__bindgen_ty_9 {
        fn default() -> Self { unsafe { ::core::mem::zeroed() } }
    }
    #[repr(C)]
    pub union pwm_reg__bindgen_ty_10 {
        pub BF: pwm_reg__bindgen_ty_10__bindgen_ty_1,
        pub WORD: u32,
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::marker::Copy for pwm_reg__bindgen_ty_10 { }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::clone::Clone for pwm_reg__bindgen_ty_10 {
        #[inline]
        fn clone(&self) -> pwm_reg__bindgen_ty_10 {
            { let _: ::core::clone::AssertParamIsCopy<Self>; *self }
        }
    }
    #[repr(C)]
    #[repr(align(4))]
    pub struct pwm_reg__bindgen_ty_10__bindgen_ty_1 {
        pub _bitfield_align_1: [u16; 0],
        pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::default::Default for pwm_reg__bindgen_ty_10__bindgen_ty_1 {
        #[inline]
        fn default() -> pwm_reg__bindgen_ty_10__bindgen_ty_1 {
            pwm_reg__bindgen_ty_10__bindgen_ty_1{_bitfield_align_1:
                                                     ::core::default::Default::default(),
                                                 _bitfield_1:
                                                     ::core::default::Default::default(),}
        }
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::marker::Copy for pwm_reg__bindgen_ty_10__bindgen_ty_1 { }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::clone::Clone for pwm_reg__bindgen_ty_10__bindgen_ty_1 {
        #[inline]
        fn clone(&self) -> pwm_reg__bindgen_ty_10__bindgen_ty_1 {
            {
                let _: ::core::clone::AssertParamIsClone<[u16; 0]>;
                let _:
                        ::core::clone::AssertParamIsClone<__BindgenBitfieldUnit<[u8; 4usize]>>;
                *self
            }
        }
    }
    impl pwm_reg__bindgen_ty_10__bindgen_ty_1 {
        #[inline]
        pub fn pwm_thre2(&self) -> u32 {
            unsafe {
                ::core::mem::transmute(self._bitfield_1.get(0usize, 16u8) as
                                           u32)
            }
        }
        #[inline]
        pub fn set_pwm_thre2(&mut self, val: u32) {
            unsafe {
                let val: u32 = ::core::mem::transmute(val);
                self._bitfield_1.set(0usize, 16u8, val as u64)
            }
        }
        #[inline]
        pub fn reserved_16_31(&self) -> u32 {
            unsafe {
                ::core::mem::transmute(self._bitfield_1.get(16usize, 16u8) as
                                           u32)
            }
        }
        #[inline]
        pub fn set_reserved_16_31(&mut self, val: u32) {
            unsafe {
                let val: u32 = ::core::mem::transmute(val);
                self._bitfield_1.set(16usize, 16u8, val as u64)
            }
        }
        #[inline]
        pub fn new_bitfield_1(pwm_thre2: u32, reserved_16_31: u32)
         -> __BindgenBitfieldUnit<[u8; 4usize]> {
            let mut __bindgen_bitfield_unit:
                    __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
            __bindgen_bitfield_unit.set(0usize, 16u8,
                                        {
                                            let pwm_thre2: u32 =
                                                unsafe {
                                                    ::core::mem::transmute(pwm_thre2)
                                                };
                                            pwm_thre2 as u64
                                        });
            __bindgen_bitfield_unit.set(16usize, 16u8,
                                        {
                                            let reserved_16_31: u32 =
                                                unsafe {
                                                    ::core::mem::transmute(reserved_16_31)
                                                };
                                            reserved_16_31 as u64
                                        });
            __bindgen_bitfield_unit
        }
    }
    impl Default for pwm_reg__bindgen_ty_10 {
        fn default() -> Self { unsafe { ::core::mem::zeroed() } }
    }
    #[repr(C)]
    pub union pwm_reg__bindgen_ty_11 {
        pub BF: pwm_reg__bindgen_ty_11__bindgen_ty_1,
        pub WORD: u32,
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::marker::Copy for pwm_reg__bindgen_ty_11 { }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::clone::Clone for pwm_reg__bindgen_ty_11 {
        #[inline]
        fn clone(&self) -> pwm_reg__bindgen_ty_11 {
            { let _: ::core::clone::AssertParamIsCopy<Self>; *self }
        }
    }
    #[repr(C)]
    #[repr(align(4))]
    pub struct pwm_reg__bindgen_ty_11__bindgen_ty_1 {
        pub _bitfield_align_1: [u16; 0],
        pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::default::Default for pwm_reg__bindgen_ty_11__bindgen_ty_1 {
        #[inline]
        fn default() -> pwm_reg__bindgen_ty_11__bindgen_ty_1 {
            pwm_reg__bindgen_ty_11__bindgen_ty_1{_bitfield_align_1:
                                                     ::core::default::Default::default(),
                                                 _bitfield_1:
                                                     ::core::default::Default::default(),}
        }
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::marker::Copy for pwm_reg__bindgen_ty_11__bindgen_ty_1 { }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::clone::Clone for pwm_reg__bindgen_ty_11__bindgen_ty_1 {
        #[inline]
        fn clone(&self) -> pwm_reg__bindgen_ty_11__bindgen_ty_1 {
            {
                let _: ::core::clone::AssertParamIsClone<[u16; 0]>;
                let _:
                        ::core::clone::AssertParamIsClone<__BindgenBitfieldUnit<[u8; 4usize]>>;
                *self
            }
        }
    }
    impl pwm_reg__bindgen_ty_11__bindgen_ty_1 {
        #[inline]
        pub fn pwm_period(&self) -> u32 {
            unsafe {
                ::core::mem::transmute(self._bitfield_1.get(0usize, 16u8) as
                                           u32)
            }
        }
        #[inline]
        pub fn set_pwm_period(&mut self, val: u32) {
            unsafe {
                let val: u32 = ::core::mem::transmute(val);
                self._bitfield_1.set(0usize, 16u8, val as u64)
            }
        }
        #[inline]
        pub fn reserved_16_31(&self) -> u32 {
            unsafe {
                ::core::mem::transmute(self._bitfield_1.get(16usize, 16u8) as
                                           u32)
            }
        }
        #[inline]
        pub fn set_reserved_16_31(&mut self, val: u32) {
            unsafe {
                let val: u32 = ::core::mem::transmute(val);
                self._bitfield_1.set(16usize, 16u8, val as u64)
            }
        }
        #[inline]
        pub fn new_bitfield_1(pwm_period: u32, reserved_16_31: u32)
         -> __BindgenBitfieldUnit<[u8; 4usize]> {
            let mut __bindgen_bitfield_unit:
                    __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
            __bindgen_bitfield_unit.set(0usize, 16u8,
                                        {
                                            let pwm_period: u32 =
                                                unsafe {
                                                    ::core::mem::transmute(pwm_period)
                                                };
                                            pwm_period as u64
                                        });
            __bindgen_bitfield_unit.set(16usize, 16u8,
                                        {
                                            let reserved_16_31: u32 =
                                                unsafe {
                                                    ::core::mem::transmute(reserved_16_31)
                                                };
                                            reserved_16_31 as u64
                                        });
            __bindgen_bitfield_unit
        }
    }
    impl Default for pwm_reg__bindgen_ty_11 {
        fn default() -> Self { unsafe { ::core::mem::zeroed() } }
    }
    #[repr(C)]
    pub union pwm_reg__bindgen_ty_12 {
        pub BF: pwm_reg__bindgen_ty_12__bindgen_ty_1,
        pub WORD: u32,
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::marker::Copy for pwm_reg__bindgen_ty_12 { }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::clone::Clone for pwm_reg__bindgen_ty_12 {
        #[inline]
        fn clone(&self) -> pwm_reg__bindgen_ty_12 {
            { let _: ::core::clone::AssertParamIsCopy<Self>; *self }
        }
    }
    #[repr(C)]
    #[repr(align(4))]
    pub struct pwm_reg__bindgen_ty_12__bindgen_ty_1 {
        pub _bitfield_align_1: [u32; 0],
        pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::default::Default for pwm_reg__bindgen_ty_12__bindgen_ty_1 {
        #[inline]
        fn default() -> pwm_reg__bindgen_ty_12__bindgen_ty_1 {
            pwm_reg__bindgen_ty_12__bindgen_ty_1{_bitfield_align_1:
                                                     ::core::default::Default::default(),
                                                 _bitfield_1:
                                                     ::core::default::Default::default(),}
        }
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::marker::Copy for pwm_reg__bindgen_ty_12__bindgen_ty_1 { }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::clone::Clone for pwm_reg__bindgen_ty_12__bindgen_ty_1 {
        #[inline]
        fn clone(&self) -> pwm_reg__bindgen_ty_12__bindgen_ty_1 {
            {
                let _: ::core::clone::AssertParamIsClone<[u32; 0]>;
                let _:
                        ::core::clone::AssertParamIsClone<__BindgenBitfieldUnit<[u8; 4usize]>>;
                *self
            }
        }
    }
    impl pwm_reg__bindgen_ty_12__bindgen_ty_1 {
        #[inline]
        pub fn reg_clk_sel(&self) -> u32 {
            unsafe {
                ::core::mem::transmute(self._bitfield_1.get(0usize, 2u8) as
                                           u32)
            }
        }
        #[inline]
        pub fn set_reg_clk_sel(&mut self, val: u32) {
            unsafe {
                let val: u32 = ::core::mem::transmute(val);
                self._bitfield_1.set(0usize, 2u8, val as u64)
            }
        }
        #[inline]
        pub fn pwm_out_inv(&self) -> u32 {
            unsafe {
                ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as
                                           u32)
            }
        }
        #[inline]
        pub fn set_pwm_out_inv(&mut self, val: u32) {
            unsafe {
                let val: u32 = ::core::mem::transmute(val);
                self._bitfield_1.set(2usize, 1u8, val as u64)
            }
        }
        #[inline]
        pub fn pwm_stop_mode(&self) -> u32 {
            unsafe {
                ::core::mem::transmute(self._bitfield_1.get(3usize, 1u8) as
                                           u32)
            }
        }
        #[inline]
        pub fn set_pwm_stop_mode(&mut self, val: u32) {
            unsafe {
                let val: u32 = ::core::mem::transmute(val);
                self._bitfield_1.set(3usize, 1u8, val as u64)
            }
        }
        #[inline]
        pub fn pwm_sw_force_val(&self) -> u32 {
            unsafe {
                ::core::mem::transmute(self._bitfield_1.get(4usize, 1u8) as
                                           u32)
            }
        }
        #[inline]
        pub fn set_pwm_sw_force_val(&mut self, val: u32) {
            unsafe {
                let val: u32 = ::core::mem::transmute(val);
                self._bitfield_1.set(4usize, 1u8, val as u64)
            }
        }
        #[inline]
        pub fn pwm_sw_mode(&self) -> u32 {
            unsafe {
                ::core::mem::transmute(self._bitfield_1.get(5usize, 1u8) as
                                           u32)
            }
        }
        #[inline]
        pub fn set_pwm_sw_mode(&mut self, val: u32) {
            unsafe {
                let val: u32 = ::core::mem::transmute(val);
                self._bitfield_1.set(5usize, 1u8, val as u64)
            }
        }
        #[inline]
        pub fn pwm_stop_en(&self) -> u32 {
            unsafe {
                ::core::mem::transmute(self._bitfield_1.get(6usize, 1u8) as
                                           u32)
            }
        }
        #[inline]
        pub fn set_pwm_stop_en(&mut self, val: u32) {
            unsafe {
                let val: u32 = ::core::mem::transmute(val);
                self._bitfield_1.set(6usize, 1u8, val as u64)
            }
        }
        #[inline]
        pub fn pwm_sts_top(&self) -> u32 {
            unsafe {
                ::core::mem::transmute(self._bitfield_1.get(7usize, 1u8) as
                                           u32)
            }
        }
        #[inline]
        pub fn set_pwm_sts_top(&mut self, val: u32) {
            unsafe {
                let val: u32 = ::core::mem::transmute(val);
                self._bitfield_1.set(7usize, 1u8, val as u64)
            }
        }
        #[inline]
        pub fn reserved_8_31(&self) -> u32 {
            unsafe {
                ::core::mem::transmute(self._bitfield_1.get(8usize, 24u8) as
                                           u32)
            }
        }
        #[inline]
        pub fn set_reserved_8_31(&mut self, val: u32) {
            unsafe {
                let val: u32 = ::core::mem::transmute(val);
                self._bitfield_1.set(8usize, 24u8, val as u64)
            }
        }
        #[inline]
        pub fn new_bitfield_1(reg_clk_sel: u32, pwm_out_inv: u32,
                              pwm_stop_mode: u32, pwm_sw_force_val: u32,
                              pwm_sw_mode: u32, pwm_stop_en: u32,
                              pwm_sts_top: u32, reserved_8_31: u32)
         -> __BindgenBitfieldUnit<[u8; 4usize]> {
            let mut __bindgen_bitfield_unit:
                    __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
            __bindgen_bitfield_unit.set(0usize, 2u8,
                                        {
                                            let reg_clk_sel: u32 =
                                                unsafe {
                                                    ::core::mem::transmute(reg_clk_sel)
                                                };
                                            reg_clk_sel as u64
                                        });
            __bindgen_bitfield_unit.set(2usize, 1u8,
                                        {
                                            let pwm_out_inv: u32 =
                                                unsafe {
                                                    ::core::mem::transmute(pwm_out_inv)
                                                };
                                            pwm_out_inv as u64
                                        });
            __bindgen_bitfield_unit.set(3usize, 1u8,
                                        {
                                            let pwm_stop_mode: u32 =
                                                unsafe {
                                                    ::core::mem::transmute(pwm_stop_mode)
                                                };
                                            pwm_stop_mode as u64
                                        });
            __bindgen_bitfield_unit.set(4usize, 1u8,
                                        {
                                            let pwm_sw_force_val: u32 =
                                                unsafe {
                                                    ::core::mem::transmute(pwm_sw_force_val)
                                                };
                                            pwm_sw_force_val as u64
                                        });
            __bindgen_bitfield_unit.set(5usize, 1u8,
                                        {
                                            let pwm_sw_mode: u32 =
                                                unsafe {
                                                    ::core::mem::transmute(pwm_sw_mode)
                                                };
                                            pwm_sw_mode as u64
                                        });
            __bindgen_bitfield_unit.set(6usize, 1u8,
                                        {
                                            let pwm_stop_en: u32 =
                                                unsafe {
                                                    ::core::mem::transmute(pwm_stop_en)
                                                };
                                            pwm_stop_en as u64
                                        });
            __bindgen_bitfield_unit.set(7usize, 1u8,
                                        {
                                            let pwm_sts_top: u32 =
                                                unsafe {
                                                    ::core::mem::transmute(pwm_sts_top)
                                                };
                                            pwm_sts_top as u64
                                        });
            __bindgen_bitfield_unit.set(8usize, 24u8,
                                        {
                                            let reserved_8_31: u32 =
                                                unsafe {
                                                    ::core::mem::transmute(reserved_8_31)
                                                };
                                            reserved_8_31 as u64
                                        });
            __bindgen_bitfield_unit
        }
    }
    impl Default for pwm_reg__bindgen_ty_12 {
        fn default() -> Self { unsafe { ::core::mem::zeroed() } }
    }
    #[repr(C)]
    pub union pwm_reg__bindgen_ty_13 {
        pub BF: pwm_reg__bindgen_ty_13__bindgen_ty_1,
        pub WORD: u32,
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::marker::Copy for pwm_reg__bindgen_ty_13 { }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::clone::Clone for pwm_reg__bindgen_ty_13 {
        #[inline]
        fn clone(&self) -> pwm_reg__bindgen_ty_13 {
            { let _: ::core::clone::AssertParamIsCopy<Self>; *self }
        }
    }
    #[repr(C)]
    #[repr(align(4))]
    pub struct pwm_reg__bindgen_ty_13__bindgen_ty_1 {
        pub _bitfield_align_1: [u16; 0],
        pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::default::Default for pwm_reg__bindgen_ty_13__bindgen_ty_1 {
        #[inline]
        fn default() -> pwm_reg__bindgen_ty_13__bindgen_ty_1 {
            pwm_reg__bindgen_ty_13__bindgen_ty_1{_bitfield_align_1:
                                                     ::core::default::Default::default(),
                                                 _bitfield_1:
                                                     ::core::default::Default::default(),}
        }
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::marker::Copy for pwm_reg__bindgen_ty_13__bindgen_ty_1 { }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::clone::Clone for pwm_reg__bindgen_ty_13__bindgen_ty_1 {
        #[inline]
        fn clone(&self) -> pwm_reg__bindgen_ty_13__bindgen_ty_1 {
            {
                let _: ::core::clone::AssertParamIsClone<[u16; 0]>;
                let _:
                        ::core::clone::AssertParamIsClone<__BindgenBitfieldUnit<[u8; 4usize]>>;
                *self
            }
        }
    }
    impl pwm_reg__bindgen_ty_13__bindgen_ty_1 {
        #[inline]
        pub fn pwm_int_period_cnt(&self) -> u32 {
            unsafe {
                ::core::mem::transmute(self._bitfield_1.get(0usize, 16u8) as
                                           u32)
            }
        }
        #[inline]
        pub fn set_pwm_int_period_cnt(&mut self, val: u32) {
            unsafe {
                let val: u32 = ::core::mem::transmute(val);
                self._bitfield_1.set(0usize, 16u8, val as u64)
            }
        }
        #[inline]
        pub fn pwm_int_enable(&self) -> u32 {
            unsafe {
                ::core::mem::transmute(self._bitfield_1.get(16usize, 1u8) as
                                           u32)
            }
        }
        #[inline]
        pub fn set_pwm_int_enable(&mut self, val: u32) {
            unsafe {
                let val: u32 = ::core::mem::transmute(val);
                self._bitfield_1.set(16usize, 1u8, val as u64)
            }
        }
        #[inline]
        pub fn reserved_17_31(&self) -> u32 {
            unsafe {
                ::core::mem::transmute(self._bitfield_1.get(17usize, 15u8) as
                                           u32)
            }
        }
        #[inline]
        pub fn set_reserved_17_31(&mut self, val: u32) {
            unsafe {
                let val: u32 = ::core::mem::transmute(val);
                self._bitfield_1.set(17usize, 15u8, val as u64)
            }
        }
        #[inline]
        pub fn new_bitfield_1(pwm_int_period_cnt: u32, pwm_int_enable: u32,
                              reserved_17_31: u32)
         -> __BindgenBitfieldUnit<[u8; 4usize]> {
            let mut __bindgen_bitfield_unit:
                    __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
            __bindgen_bitfield_unit.set(0usize, 16u8,
                                        {
                                            let pwm_int_period_cnt: u32 =
                                                unsafe {
                                                    ::core::mem::transmute(pwm_int_period_cnt)
                                                };
                                            pwm_int_period_cnt as u64
                                        });
            __bindgen_bitfield_unit.set(16usize, 1u8,
                                        {
                                            let pwm_int_enable: u32 =
                                                unsafe {
                                                    ::core::mem::transmute(pwm_int_enable)
                                                };
                                            pwm_int_enable as u64
                                        });
            __bindgen_bitfield_unit.set(17usize, 15u8,
                                        {
                                            let reserved_17_31: u32 =
                                                unsafe {
                                                    ::core::mem::transmute(reserved_17_31)
                                                };
                                            reserved_17_31 as u64
                                        });
            __bindgen_bitfield_unit
        }
    }
    impl Default for pwm_reg__bindgen_ty_13 {
        fn default() -> Self { unsafe { ::core::mem::zeroed() } }
    }
    #[repr(C)]
    pub union pwm_reg__bindgen_ty_14 {
        pub BF: pwm_reg__bindgen_ty_14__bindgen_ty_1,
        pub WORD: u32,
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::marker::Copy for pwm_reg__bindgen_ty_14 { }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::clone::Clone for pwm_reg__bindgen_ty_14 {
        #[inline]
        fn clone(&self) -> pwm_reg__bindgen_ty_14 {
            { let _: ::core::clone::AssertParamIsCopy<Self>; *self }
        }
    }
    #[repr(C)]
    #[repr(align(4))]
    pub struct pwm_reg__bindgen_ty_14__bindgen_ty_1 {
        pub _bitfield_align_1: [u16; 0],
        pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::default::Default for pwm_reg__bindgen_ty_14__bindgen_ty_1 {
        #[inline]
        fn default() -> pwm_reg__bindgen_ty_14__bindgen_ty_1 {
            pwm_reg__bindgen_ty_14__bindgen_ty_1{_bitfield_align_1:
                                                     ::core::default::Default::default(),
                                                 _bitfield_1:
                                                     ::core::default::Default::default(),}
        }
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::marker::Copy for pwm_reg__bindgen_ty_14__bindgen_ty_1 { }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::clone::Clone for pwm_reg__bindgen_ty_14__bindgen_ty_1 {
        #[inline]
        fn clone(&self) -> pwm_reg__bindgen_ty_14__bindgen_ty_1 {
            {
                let _: ::core::clone::AssertParamIsClone<[u16; 0]>;
                let _:
                        ::core::clone::AssertParamIsClone<__BindgenBitfieldUnit<[u8; 4usize]>>;
                *self
            }
        }
    }
    impl pwm_reg__bindgen_ty_14__bindgen_ty_1 {
        #[inline]
        pub fn pwm_clk_div(&self) -> u32 {
            unsafe {
                ::core::mem::transmute(self._bitfield_1.get(0usize, 16u8) as
                                           u32)
            }
        }
        #[inline]
        pub fn set_pwm_clk_div(&mut self, val: u32) {
            unsafe {
                let val: u32 = ::core::mem::transmute(val);
                self._bitfield_1.set(0usize, 16u8, val as u64)
            }
        }
        #[inline]
        pub fn reserved_16_31(&self) -> u32 {
            unsafe {
                ::core::mem::transmute(self._bitfield_1.get(16usize, 16u8) as
                                           u32)
            }
        }
        #[inline]
        pub fn set_reserved_16_31(&mut self, val: u32) {
            unsafe {
                let val: u32 = ::core::mem::transmute(val);
                self._bitfield_1.set(16usize, 16u8, val as u64)
            }
        }
        #[inline]
        pub fn new_bitfield_1(pwm_clk_div: u32, reserved_16_31: u32)
         -> __BindgenBitfieldUnit<[u8; 4usize]> {
            let mut __bindgen_bitfield_unit:
                    __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
            __bindgen_bitfield_unit.set(0usize, 16u8,
                                        {
                                            let pwm_clk_div: u32 =
                                                unsafe {
                                                    ::core::mem::transmute(pwm_clk_div)
                                                };
                                            pwm_clk_div as u64
                                        });
            __bindgen_bitfield_unit.set(16usize, 16u8,
                                        {
                                            let reserved_16_31: u32 =
                                                unsafe {
                                                    ::core::mem::transmute(reserved_16_31)
                                                };
                                            reserved_16_31 as u64
                                        });
            __bindgen_bitfield_unit
        }
    }
    impl Default for pwm_reg__bindgen_ty_14 {
        fn default() -> Self { unsafe { ::core::mem::zeroed() } }
    }
    #[repr(C)]
    pub union pwm_reg__bindgen_ty_15 {
        pub BF: pwm_reg__bindgen_ty_15__bindgen_ty_1,
        pub WORD: u32,
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::marker::Copy for pwm_reg__bindgen_ty_15 { }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::clone::Clone for pwm_reg__bindgen_ty_15 {
        #[inline]
        fn clone(&self) -> pwm_reg__bindgen_ty_15 {
            { let _: ::core::clone::AssertParamIsCopy<Self>; *self }
        }
    }
    #[repr(C)]
    #[repr(align(4))]
    pub struct pwm_reg__bindgen_ty_15__bindgen_ty_1 {
        pub _bitfield_align_1: [u16; 0],
        pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::default::Default for pwm_reg__bindgen_ty_15__bindgen_ty_1 {
        #[inline]
        fn default() -> pwm_reg__bindgen_ty_15__bindgen_ty_1 {
            pwm_reg__bindgen_ty_15__bindgen_ty_1{_bitfield_align_1:
                                                     ::core::default::Default::default(),
                                                 _bitfield_1:
                                                     ::core::default::Default::default(),}
        }
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::marker::Copy for pwm_reg__bindgen_ty_15__bindgen_ty_1 { }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::clone::Clone for pwm_reg__bindgen_ty_15__bindgen_ty_1 {
        #[inline]
        fn clone(&self) -> pwm_reg__bindgen_ty_15__bindgen_ty_1 {
            {
                let _: ::core::clone::AssertParamIsClone<[u16; 0]>;
                let _:
                        ::core::clone::AssertParamIsClone<__BindgenBitfieldUnit<[u8; 4usize]>>;
                *self
            }
        }
    }
    impl pwm_reg__bindgen_ty_15__bindgen_ty_1 {
        #[inline]
        pub fn pwm_thre1(&self) -> u32 {
            unsafe {
                ::core::mem::transmute(self._bitfield_1.get(0usize, 16u8) as
                                           u32)
            }
        }
        #[inline]
        pub fn set_pwm_thre1(&mut self, val: u32) {
            unsafe {
                let val: u32 = ::core::mem::transmute(val);
                self._bitfield_1.set(0usize, 16u8, val as u64)
            }
        }
        #[inline]
        pub fn reserved_16_31(&self) -> u32 {
            unsafe {
                ::core::mem::transmute(self._bitfield_1.get(16usize, 16u8) as
                                           u32)
            }
        }
        #[inline]
        pub fn set_reserved_16_31(&mut self, val: u32) {
            unsafe {
                let val: u32 = ::core::mem::transmute(val);
                self._bitfield_1.set(16usize, 16u8, val as u64)
            }
        }
        #[inline]
        pub fn new_bitfield_1(pwm_thre1: u32, reserved_16_31: u32)
         -> __BindgenBitfieldUnit<[u8; 4usize]> {
            let mut __bindgen_bitfield_unit:
                    __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
            __bindgen_bitfield_unit.set(0usize, 16u8,
                                        {
                                            let pwm_thre1: u32 =
                                                unsafe {
                                                    ::core::mem::transmute(pwm_thre1)
                                                };
                                            pwm_thre1 as u64
                                        });
            __bindgen_bitfield_unit.set(16usize, 16u8,
                                        {
                                            let reserved_16_31: u32 =
                                                unsafe {
                                                    ::core::mem::transmute(reserved_16_31)
                                                };
                                            reserved_16_31 as u64
                                        });
            __bindgen_bitfield_unit
        }
    }
    impl Default for pwm_reg__bindgen_ty_15 {
        fn default() -> Self { unsafe { ::core::mem::zeroed() } }
    }
    #[repr(C)]
    pub union pwm_reg__bindgen_ty_16 {
        pub BF: pwm_reg__bindgen_ty_16__bindgen_ty_1,
        pub WORD: u32,
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::marker::Copy for pwm_reg__bindgen_ty_16 { }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::clone::Clone for pwm_reg__bindgen_ty_16 {
        #[inline]
        fn clone(&self) -> pwm_reg__bindgen_ty_16 {
            { let _: ::core::clone::AssertParamIsCopy<Self>; *self }
        }
    }
    #[repr(C)]
    #[repr(align(4))]
    pub struct pwm_reg__bindgen_ty_16__bindgen_ty_1 {
        pub _bitfield_align_1: [u16; 0],
        pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::default::Default for pwm_reg__bindgen_ty_16__bindgen_ty_1 {
        #[inline]
        fn default() -> pwm_reg__bindgen_ty_16__bindgen_ty_1 {
            pwm_reg__bindgen_ty_16__bindgen_ty_1{_bitfield_align_1:
                                                     ::core::default::Default::default(),
                                                 _bitfield_1:
                                                     ::core::default::Default::default(),}
        }
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::marker::Copy for pwm_reg__bindgen_ty_16__bindgen_ty_1 { }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::clone::Clone for pwm_reg__bindgen_ty_16__bindgen_ty_1 {
        #[inline]
        fn clone(&self) -> pwm_reg__bindgen_ty_16__bindgen_ty_1 {
            {
                let _: ::core::clone::AssertParamIsClone<[u16; 0]>;
                let _:
                        ::core::clone::AssertParamIsClone<__BindgenBitfieldUnit<[u8; 4usize]>>;
                *self
            }
        }
    }
    impl pwm_reg__bindgen_ty_16__bindgen_ty_1 {
        #[inline]
        pub fn pwm_thre2(&self) -> u32 {
            unsafe {
                ::core::mem::transmute(self._bitfield_1.get(0usize, 16u8) as
                                           u32)
            }
        }
        #[inline]
        pub fn set_pwm_thre2(&mut self, val: u32) {
            unsafe {
                let val: u32 = ::core::mem::transmute(val);
                self._bitfield_1.set(0usize, 16u8, val as u64)
            }
        }
        #[inline]
        pub fn reserved_16_31(&self) -> u32 {
            unsafe {
                ::core::mem::transmute(self._bitfield_1.get(16usize, 16u8) as
                                           u32)
            }
        }
        #[inline]
        pub fn set_reserved_16_31(&mut self, val: u32) {
            unsafe {
                let val: u32 = ::core::mem::transmute(val);
                self._bitfield_1.set(16usize, 16u8, val as u64)
            }
        }
        #[inline]
        pub fn new_bitfield_1(pwm_thre2: u32, reserved_16_31: u32)
         -> __BindgenBitfieldUnit<[u8; 4usize]> {
            let mut __bindgen_bitfield_unit:
                    __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
            __bindgen_bitfield_unit.set(0usize, 16u8,
                                        {
                                            let pwm_thre2: u32 =
                                                unsafe {
                                                    ::core::mem::transmute(pwm_thre2)
                                                };
                                            pwm_thre2 as u64
                                        });
            __bindgen_bitfield_unit.set(16usize, 16u8,
                                        {
                                            let reserved_16_31: u32 =
                                                unsafe {
                                                    ::core::mem::transmute(reserved_16_31)
                                                };
                                            reserved_16_31 as u64
                                        });
            __bindgen_bitfield_unit
        }
    }
    impl Default for pwm_reg__bindgen_ty_16 {
        fn default() -> Self { unsafe { ::core::mem::zeroed() } }
    }
    #[repr(C)]
    pub union pwm_reg__bindgen_ty_17 {
        pub BF: pwm_reg__bindgen_ty_17__bindgen_ty_1,
        pub WORD: u32,
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::marker::Copy for pwm_reg__bindgen_ty_17 { }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::clone::Clone for pwm_reg__bindgen_ty_17 {
        #[inline]
        fn clone(&self) -> pwm_reg__bindgen_ty_17 {
            { let _: ::core::clone::AssertParamIsCopy<Self>; *self }
        }
    }
    #[repr(C)]
    #[repr(align(4))]
    pub struct pwm_reg__bindgen_ty_17__bindgen_ty_1 {
        pub _bitfield_align_1: [u16; 0],
        pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::default::Default for pwm_reg__bindgen_ty_17__bindgen_ty_1 {
        #[inline]
        fn default() -> pwm_reg__bindgen_ty_17__bindgen_ty_1 {
            pwm_reg__bindgen_ty_17__bindgen_ty_1{_bitfield_align_1:
                                                     ::core::default::Default::default(),
                                                 _bitfield_1:
                                                     ::core::default::Default::default(),}
        }
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::marker::Copy for pwm_reg__bindgen_ty_17__bindgen_ty_1 { }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::clone::Clone for pwm_reg__bindgen_ty_17__bindgen_ty_1 {
        #[inline]
        fn clone(&self) -> pwm_reg__bindgen_ty_17__bindgen_ty_1 {
            {
                let _: ::core::clone::AssertParamIsClone<[u16; 0]>;
                let _:
                        ::core::clone::AssertParamIsClone<__BindgenBitfieldUnit<[u8; 4usize]>>;
                *self
            }
        }
    }
    impl pwm_reg__bindgen_ty_17__bindgen_ty_1 {
        #[inline]
        pub fn pwm_period(&self) -> u32 {
            unsafe {
                ::core::mem::transmute(self._bitfield_1.get(0usize, 16u8) as
                                           u32)
            }
        }
        #[inline]
        pub fn set_pwm_period(&mut self, val: u32) {
            unsafe {
                let val: u32 = ::core::mem::transmute(val);
                self._bitfield_1.set(0usize, 16u8, val as u64)
            }
        }
        #[inline]
        pub fn reserved_16_31(&self) -> u32 {
            unsafe {
                ::core::mem::transmute(self._bitfield_1.get(16usize, 16u8) as
                                           u32)
            }
        }
        #[inline]
        pub fn set_reserved_16_31(&mut self, val: u32) {
            unsafe {
                let val: u32 = ::core::mem::transmute(val);
                self._bitfield_1.set(16usize, 16u8, val as u64)
            }
        }
        #[inline]
        pub fn new_bitfield_1(pwm_period: u32, reserved_16_31: u32)
         -> __BindgenBitfieldUnit<[u8; 4usize]> {
            let mut __bindgen_bitfield_unit:
                    __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
            __bindgen_bitfield_unit.set(0usize, 16u8,
                                        {
                                            let pwm_period: u32 =
                                                unsafe {
                                                    ::core::mem::transmute(pwm_period)
                                                };
                                            pwm_period as u64
                                        });
            __bindgen_bitfield_unit.set(16usize, 16u8,
                                        {
                                            let reserved_16_31: u32 =
                                                unsafe {
                                                    ::core::mem::transmute(reserved_16_31)
                                                };
                                            reserved_16_31 as u64
                                        });
            __bindgen_bitfield_unit
        }
    }
    impl Default for pwm_reg__bindgen_ty_17 {
        fn default() -> Self { unsafe { ::core::mem::zeroed() } }
    }
    #[repr(C)]
    pub union pwm_reg__bindgen_ty_18 {
        pub BF: pwm_reg__bindgen_ty_18__bindgen_ty_1,
        pub WORD: u32,
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::marker::Copy for pwm_reg__bindgen_ty_18 { }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::clone::Clone for pwm_reg__bindgen_ty_18 {
        #[inline]
        fn clone(&self) -> pwm_reg__bindgen_ty_18 {
            { let _: ::core::clone::AssertParamIsCopy<Self>; *self }
        }
    }
    #[repr(C)]
    #[repr(align(4))]
    pub struct pwm_reg__bindgen_ty_18__bindgen_ty_1 {
        pub _bitfield_align_1: [u32; 0],
        pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::default::Default for pwm_reg__bindgen_ty_18__bindgen_ty_1 {
        #[inline]
        fn default() -> pwm_reg__bindgen_ty_18__bindgen_ty_1 {
            pwm_reg__bindgen_ty_18__bindgen_ty_1{_bitfield_align_1:
                                                     ::core::default::Default::default(),
                                                 _bitfield_1:
                                                     ::core::default::Default::default(),}
        }
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::marker::Copy for pwm_reg__bindgen_ty_18__bindgen_ty_1 { }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::clone::Clone for pwm_reg__bindgen_ty_18__bindgen_ty_1 {
        #[inline]
        fn clone(&self) -> pwm_reg__bindgen_ty_18__bindgen_ty_1 {
            {
                let _: ::core::clone::AssertParamIsClone<[u32; 0]>;
                let _:
                        ::core::clone::AssertParamIsClone<__BindgenBitfieldUnit<[u8; 4usize]>>;
                *self
            }
        }
    }
    impl pwm_reg__bindgen_ty_18__bindgen_ty_1 {
        #[inline]
        pub fn reg_clk_sel(&self) -> u32 {
            unsafe {
                ::core::mem::transmute(self._bitfield_1.get(0usize, 2u8) as
                                           u32)
            }
        }
        #[inline]
        pub fn set_reg_clk_sel(&mut self, val: u32) {
            unsafe {
                let val: u32 = ::core::mem::transmute(val);
                self._bitfield_1.set(0usize, 2u8, val as u64)
            }
        }
        #[inline]
        pub fn pwm_out_inv(&self) -> u32 {
            unsafe {
                ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as
                                           u32)
            }
        }
        #[inline]
        pub fn set_pwm_out_inv(&mut self, val: u32) {
            unsafe {
                let val: u32 = ::core::mem::transmute(val);
                self._bitfield_1.set(2usize, 1u8, val as u64)
            }
        }
        #[inline]
        pub fn pwm_stop_mode(&self) -> u32 {
            unsafe {
                ::core::mem::transmute(self._bitfield_1.get(3usize, 1u8) as
                                           u32)
            }
        }
        #[inline]
        pub fn set_pwm_stop_mode(&mut self, val: u32) {
            unsafe {
                let val: u32 = ::core::mem::transmute(val);
                self._bitfield_1.set(3usize, 1u8, val as u64)
            }
        }
        #[inline]
        pub fn pwm_sw_force_val(&self) -> u32 {
            unsafe {
                ::core::mem::transmute(self._bitfield_1.get(4usize, 1u8) as
                                           u32)
            }
        }
        #[inline]
        pub fn set_pwm_sw_force_val(&mut self, val: u32) {
            unsafe {
                let val: u32 = ::core::mem::transmute(val);
                self._bitfield_1.set(4usize, 1u8, val as u64)
            }
        }
        #[inline]
        pub fn pwm_sw_mode(&self) -> u32 {
            unsafe {
                ::core::mem::transmute(self._bitfield_1.get(5usize, 1u8) as
                                           u32)
            }
        }
        #[inline]
        pub fn set_pwm_sw_mode(&mut self, val: u32) {
            unsafe {
                let val: u32 = ::core::mem::transmute(val);
                self._bitfield_1.set(5usize, 1u8, val as u64)
            }
        }
        #[inline]
        pub fn pwm_stop_en(&self) -> u32 {
            unsafe {
                ::core::mem::transmute(self._bitfield_1.get(6usize, 1u8) as
                                           u32)
            }
        }
        #[inline]
        pub fn set_pwm_stop_en(&mut self, val: u32) {
            unsafe {
                let val: u32 = ::core::mem::transmute(val);
                self._bitfield_1.set(6usize, 1u8, val as u64)
            }
        }
        #[inline]
        pub fn pwm_sts_top(&self) -> u32 {
            unsafe {
                ::core::mem::transmute(self._bitfield_1.get(7usize, 1u8) as
                                           u32)
            }
        }
        #[inline]
        pub fn set_pwm_sts_top(&mut self, val: u32) {
            unsafe {
                let val: u32 = ::core::mem::transmute(val);
                self._bitfield_1.set(7usize, 1u8, val as u64)
            }
        }
        #[inline]
        pub fn reserved_8_31(&self) -> u32 {
            unsafe {
                ::core::mem::transmute(self._bitfield_1.get(8usize, 24u8) as
                                           u32)
            }
        }
        #[inline]
        pub fn set_reserved_8_31(&mut self, val: u32) {
            unsafe {
                let val: u32 = ::core::mem::transmute(val);
                self._bitfield_1.set(8usize, 24u8, val as u64)
            }
        }
        #[inline]
        pub fn new_bitfield_1(reg_clk_sel: u32, pwm_out_inv: u32,
                              pwm_stop_mode: u32, pwm_sw_force_val: u32,
                              pwm_sw_mode: u32, pwm_stop_en: u32,
                              pwm_sts_top: u32, reserved_8_31: u32)
         -> __BindgenBitfieldUnit<[u8; 4usize]> {
            let mut __bindgen_bitfield_unit:
                    __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
            __bindgen_bitfield_unit.set(0usize, 2u8,
                                        {
                                            let reg_clk_sel: u32 =
                                                unsafe {
                                                    ::core::mem::transmute(reg_clk_sel)
                                                };
                                            reg_clk_sel as u64
                                        });
            __bindgen_bitfield_unit.set(2usize, 1u8,
                                        {
                                            let pwm_out_inv: u32 =
                                                unsafe {
                                                    ::core::mem::transmute(pwm_out_inv)
                                                };
                                            pwm_out_inv as u64
                                        });
            __bindgen_bitfield_unit.set(3usize, 1u8,
                                        {
                                            let pwm_stop_mode: u32 =
                                                unsafe {
                                                    ::core::mem::transmute(pwm_stop_mode)
                                                };
                                            pwm_stop_mode as u64
                                        });
            __bindgen_bitfield_unit.set(4usize, 1u8,
                                        {
                                            let pwm_sw_force_val: u32 =
                                                unsafe {
                                                    ::core::mem::transmute(pwm_sw_force_val)
                                                };
                                            pwm_sw_force_val as u64
                                        });
            __bindgen_bitfield_unit.set(5usize, 1u8,
                                        {
                                            let pwm_sw_mode: u32 =
                                                unsafe {
                                                    ::core::mem::transmute(pwm_sw_mode)
                                                };
                                            pwm_sw_mode as u64
                                        });
            __bindgen_bitfield_unit.set(6usize, 1u8,
                                        {
                                            let pwm_stop_en: u32 =
                                                unsafe {
                                                    ::core::mem::transmute(pwm_stop_en)
                                                };
                                            pwm_stop_en as u64
                                        });
            __bindgen_bitfield_unit.set(7usize, 1u8,
                                        {
                                            let pwm_sts_top: u32 =
                                                unsafe {
                                                    ::core::mem::transmute(pwm_sts_top)
                                                };
                                            pwm_sts_top as u64
                                        });
            __bindgen_bitfield_unit.set(8usize, 24u8,
                                        {
                                            let reserved_8_31: u32 =
                                                unsafe {
                                                    ::core::mem::transmute(reserved_8_31)
                                                };
                                            reserved_8_31 as u64
                                        });
            __bindgen_bitfield_unit
        }
    }
    impl Default for pwm_reg__bindgen_ty_18 {
        fn default() -> Self { unsafe { ::core::mem::zeroed() } }
    }
    #[repr(C)]
    pub union pwm_reg__bindgen_ty_19 {
        pub BF: pwm_reg__bindgen_ty_19__bindgen_ty_1,
        pub WORD: u32,
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::marker::Copy for pwm_reg__bindgen_ty_19 { }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::clone::Clone for pwm_reg__bindgen_ty_19 {
        #[inline]
        fn clone(&self) -> pwm_reg__bindgen_ty_19 {
            { let _: ::core::clone::AssertParamIsCopy<Self>; *self }
        }
    }
    #[repr(C)]
    #[repr(align(4))]
    pub struct pwm_reg__bindgen_ty_19__bindgen_ty_1 {
        pub _bitfield_align_1: [u16; 0],
        pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::default::Default for pwm_reg__bindgen_ty_19__bindgen_ty_1 {
        #[inline]
        fn default() -> pwm_reg__bindgen_ty_19__bindgen_ty_1 {
            pwm_reg__bindgen_ty_19__bindgen_ty_1{_bitfield_align_1:
                                                     ::core::default::Default::default(),
                                                 _bitfield_1:
                                                     ::core::default::Default::default(),}
        }
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::marker::Copy for pwm_reg__bindgen_ty_19__bindgen_ty_1 { }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::clone::Clone for pwm_reg__bindgen_ty_19__bindgen_ty_1 {
        #[inline]
        fn clone(&self) -> pwm_reg__bindgen_ty_19__bindgen_ty_1 {
            {
                let _: ::core::clone::AssertParamIsClone<[u16; 0]>;
                let _:
                        ::core::clone::AssertParamIsClone<__BindgenBitfieldUnit<[u8; 4usize]>>;
                *self
            }
        }
    }
    impl pwm_reg__bindgen_ty_19__bindgen_ty_1 {
        #[inline]
        pub fn pwm_int_period_cnt(&self) -> u32 {
            unsafe {
                ::core::mem::transmute(self._bitfield_1.get(0usize, 16u8) as
                                           u32)
            }
        }
        #[inline]
        pub fn set_pwm_int_period_cnt(&mut self, val: u32) {
            unsafe {
                let val: u32 = ::core::mem::transmute(val);
                self._bitfield_1.set(0usize, 16u8, val as u64)
            }
        }
        #[inline]
        pub fn pwm_int_enable(&self) -> u32 {
            unsafe {
                ::core::mem::transmute(self._bitfield_1.get(16usize, 1u8) as
                                           u32)
            }
        }
        #[inline]
        pub fn set_pwm_int_enable(&mut self, val: u32) {
            unsafe {
                let val: u32 = ::core::mem::transmute(val);
                self._bitfield_1.set(16usize, 1u8, val as u64)
            }
        }
        #[inline]
        pub fn reserved_17_31(&self) -> u32 {
            unsafe {
                ::core::mem::transmute(self._bitfield_1.get(17usize, 15u8) as
                                           u32)
            }
        }
        #[inline]
        pub fn set_reserved_17_31(&mut self, val: u32) {
            unsafe {
                let val: u32 = ::core::mem::transmute(val);
                self._bitfield_1.set(17usize, 15u8, val as u64)
            }
        }
        #[inline]
        pub fn new_bitfield_1(pwm_int_period_cnt: u32, pwm_int_enable: u32,
                              reserved_17_31: u32)
         -> __BindgenBitfieldUnit<[u8; 4usize]> {
            let mut __bindgen_bitfield_unit:
                    __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
            __bindgen_bitfield_unit.set(0usize, 16u8,
                                        {
                                            let pwm_int_period_cnt: u32 =
                                                unsafe {
                                                    ::core::mem::transmute(pwm_int_period_cnt)
                                                };
                                            pwm_int_period_cnt as u64
                                        });
            __bindgen_bitfield_unit.set(16usize, 1u8,
                                        {
                                            let pwm_int_enable: u32 =
                                                unsafe {
                                                    ::core::mem::transmute(pwm_int_enable)
                                                };
                                            pwm_int_enable as u64
                                        });
            __bindgen_bitfield_unit.set(17usize, 15u8,
                                        {
                                            let reserved_17_31: u32 =
                                                unsafe {
                                                    ::core::mem::transmute(reserved_17_31)
                                                };
                                            reserved_17_31 as u64
                                        });
            __bindgen_bitfield_unit
        }
    }
    impl Default for pwm_reg__bindgen_ty_19 {
        fn default() -> Self { unsafe { ::core::mem::zeroed() } }
    }
    #[repr(C)]
    pub union pwm_reg__bindgen_ty_20 {
        pub BF: pwm_reg__bindgen_ty_20__bindgen_ty_1,
        pub WORD: u32,
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::marker::Copy for pwm_reg__bindgen_ty_20 { }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::clone::Clone for pwm_reg__bindgen_ty_20 {
        #[inline]
        fn clone(&self) -> pwm_reg__bindgen_ty_20 {
            { let _: ::core::clone::AssertParamIsCopy<Self>; *self }
        }
    }
    #[repr(C)]
    #[repr(align(4))]
    pub struct pwm_reg__bindgen_ty_20__bindgen_ty_1 {
        pub _bitfield_align_1: [u16; 0],
        pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::default::Default for pwm_reg__bindgen_ty_20__bindgen_ty_1 {
        #[inline]
        fn default() -> pwm_reg__bindgen_ty_20__bindgen_ty_1 {
            pwm_reg__bindgen_ty_20__bindgen_ty_1{_bitfield_align_1:
                                                     ::core::default::Default::default(),
                                                 _bitfield_1:
                                                     ::core::default::Default::default(),}
        }
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::marker::Copy for pwm_reg__bindgen_ty_20__bindgen_ty_1 { }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::clone::Clone for pwm_reg__bindgen_ty_20__bindgen_ty_1 {
        #[inline]
        fn clone(&self) -> pwm_reg__bindgen_ty_20__bindgen_ty_1 {
            {
                let _: ::core::clone::AssertParamIsClone<[u16; 0]>;
                let _:
                        ::core::clone::AssertParamIsClone<__BindgenBitfieldUnit<[u8; 4usize]>>;
                *self
            }
        }
    }
    impl pwm_reg__bindgen_ty_20__bindgen_ty_1 {
        #[inline]
        pub fn pwm_clk_div(&self) -> u32 {
            unsafe {
                ::core::mem::transmute(self._bitfield_1.get(0usize, 16u8) as
                                           u32)
            }
        }
        #[inline]
        pub fn set_pwm_clk_div(&mut self, val: u32) {
            unsafe {
                let val: u32 = ::core::mem::transmute(val);
                self._bitfield_1.set(0usize, 16u8, val as u64)
            }
        }
        #[inline]
        pub fn reserved_16_31(&self) -> u32 {
            unsafe {
                ::core::mem::transmute(self._bitfield_1.get(16usize, 16u8) as
                                           u32)
            }
        }
        #[inline]
        pub fn set_reserved_16_31(&mut self, val: u32) {
            unsafe {
                let val: u32 = ::core::mem::transmute(val);
                self._bitfield_1.set(16usize, 16u8, val as u64)
            }
        }
        #[inline]
        pub fn new_bitfield_1(pwm_clk_div: u32, reserved_16_31: u32)
         -> __BindgenBitfieldUnit<[u8; 4usize]> {
            let mut __bindgen_bitfield_unit:
                    __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
            __bindgen_bitfield_unit.set(0usize, 16u8,
                                        {
                                            let pwm_clk_div: u32 =
                                                unsafe {
                                                    ::core::mem::transmute(pwm_clk_div)
                                                };
                                            pwm_clk_div as u64
                                        });
            __bindgen_bitfield_unit.set(16usize, 16u8,
                                        {
                                            let reserved_16_31: u32 =
                                                unsafe {
                                                    ::core::mem::transmute(reserved_16_31)
                                                };
                                            reserved_16_31 as u64
                                        });
            __bindgen_bitfield_unit
        }
    }
    impl Default for pwm_reg__bindgen_ty_20 {
        fn default() -> Self { unsafe { ::core::mem::zeroed() } }
    }
    #[repr(C)]
    pub union pwm_reg__bindgen_ty_21 {
        pub BF: pwm_reg__bindgen_ty_21__bindgen_ty_1,
        pub WORD: u32,
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::marker::Copy for pwm_reg__bindgen_ty_21 { }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::clone::Clone for pwm_reg__bindgen_ty_21 {
        #[inline]
        fn clone(&self) -> pwm_reg__bindgen_ty_21 {
            { let _: ::core::clone::AssertParamIsCopy<Self>; *self }
        }
    }
    #[repr(C)]
    #[repr(align(4))]
    pub struct pwm_reg__bindgen_ty_21__bindgen_ty_1 {
        pub _bitfield_align_1: [u16; 0],
        pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::default::Default for pwm_reg__bindgen_ty_21__bindgen_ty_1 {
        #[inline]
        fn default() -> pwm_reg__bindgen_ty_21__bindgen_ty_1 {
            pwm_reg__bindgen_ty_21__bindgen_ty_1{_bitfield_align_1:
                                                     ::core::default::Default::default(),
                                                 _bitfield_1:
                                                     ::core::default::Default::default(),}
        }
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::marker::Copy for pwm_reg__bindgen_ty_21__bindgen_ty_1 { }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::clone::Clone for pwm_reg__bindgen_ty_21__bindgen_ty_1 {
        #[inline]
        fn clone(&self) -> pwm_reg__bindgen_ty_21__bindgen_ty_1 {
            {
                let _: ::core::clone::AssertParamIsClone<[u16; 0]>;
                let _:
                        ::core::clone::AssertParamIsClone<__BindgenBitfieldUnit<[u8; 4usize]>>;
                *self
            }
        }
    }
    impl pwm_reg__bindgen_ty_21__bindgen_ty_1 {
        #[inline]
        pub fn pwm_thre1(&self) -> u32 {
            unsafe {
                ::core::mem::transmute(self._bitfield_1.get(0usize, 16u8) as
                                           u32)
            }
        }
        #[inline]
        pub fn set_pwm_thre1(&mut self, val: u32) {
            unsafe {
                let val: u32 = ::core::mem::transmute(val);
                self._bitfield_1.set(0usize, 16u8, val as u64)
            }
        }
        #[inline]
        pub fn reserved_16_31(&self) -> u32 {
            unsafe {
                ::core::mem::transmute(self._bitfield_1.get(16usize, 16u8) as
                                           u32)
            }
        }
        #[inline]
        pub fn set_reserved_16_31(&mut self, val: u32) {
            unsafe {
                let val: u32 = ::core::mem::transmute(val);
                self._bitfield_1.set(16usize, 16u8, val as u64)
            }
        }
        #[inline]
        pub fn new_bitfield_1(pwm_thre1: u32, reserved_16_31: u32)
         -> __BindgenBitfieldUnit<[u8; 4usize]> {
            let mut __bindgen_bitfield_unit:
                    __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
            __bindgen_bitfield_unit.set(0usize, 16u8,
                                        {
                                            let pwm_thre1: u32 =
                                                unsafe {
                                                    ::core::mem::transmute(pwm_thre1)
                                                };
                                            pwm_thre1 as u64
                                        });
            __bindgen_bitfield_unit.set(16usize, 16u8,
                                        {
                                            let reserved_16_31: u32 =
                                                unsafe {
                                                    ::core::mem::transmute(reserved_16_31)
                                                };
                                            reserved_16_31 as u64
                                        });
            __bindgen_bitfield_unit
        }
    }
    impl Default for pwm_reg__bindgen_ty_21 {
        fn default() -> Self { unsafe { ::core::mem::zeroed() } }
    }
    #[repr(C)]
    pub union pwm_reg__bindgen_ty_22 {
        pub BF: pwm_reg__bindgen_ty_22__bindgen_ty_1,
        pub WORD: u32,
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::marker::Copy for pwm_reg__bindgen_ty_22 { }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::clone::Clone for pwm_reg__bindgen_ty_22 {
        #[inline]
        fn clone(&self) -> pwm_reg__bindgen_ty_22 {
            { let _: ::core::clone::AssertParamIsCopy<Self>; *self }
        }
    }
    #[repr(C)]
    #[repr(align(4))]
    pub struct pwm_reg__bindgen_ty_22__bindgen_ty_1 {
        pub _bitfield_align_1: [u16; 0],
        pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::default::Default for pwm_reg__bindgen_ty_22__bindgen_ty_1 {
        #[inline]
        fn default() -> pwm_reg__bindgen_ty_22__bindgen_ty_1 {
            pwm_reg__bindgen_ty_22__bindgen_ty_1{_bitfield_align_1:
                                                     ::core::default::Default::default(),
                                                 _bitfield_1:
                                                     ::core::default::Default::default(),}
        }
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::marker::Copy for pwm_reg__bindgen_ty_22__bindgen_ty_1 { }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::clone::Clone for pwm_reg__bindgen_ty_22__bindgen_ty_1 {
        #[inline]
        fn clone(&self) -> pwm_reg__bindgen_ty_22__bindgen_ty_1 {
            {
                let _: ::core::clone::AssertParamIsClone<[u16; 0]>;
                let _:
                        ::core::clone::AssertParamIsClone<__BindgenBitfieldUnit<[u8; 4usize]>>;
                *self
            }
        }
    }
    impl pwm_reg__bindgen_ty_22__bindgen_ty_1 {
        #[inline]
        pub fn pwm_thre2(&self) -> u32 {
            unsafe {
                ::core::mem::transmute(self._bitfield_1.get(0usize, 16u8) as
                                           u32)
            }
        }
        #[inline]
        pub fn set_pwm_thre2(&mut self, val: u32) {
            unsafe {
                let val: u32 = ::core::mem::transmute(val);
                self._bitfield_1.set(0usize, 16u8, val as u64)
            }
        }
        #[inline]
        pub fn reserved_16_31(&self) -> u32 {
            unsafe {
                ::core::mem::transmute(self._bitfield_1.get(16usize, 16u8) as
                                           u32)
            }
        }
        #[inline]
        pub fn set_reserved_16_31(&mut self, val: u32) {
            unsafe {
                let val: u32 = ::core::mem::transmute(val);
                self._bitfield_1.set(16usize, 16u8, val as u64)
            }
        }
        #[inline]
        pub fn new_bitfield_1(pwm_thre2: u32, reserved_16_31: u32)
         -> __BindgenBitfieldUnit<[u8; 4usize]> {
            let mut __bindgen_bitfield_unit:
                    __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
            __bindgen_bitfield_unit.set(0usize, 16u8,
                                        {
                                            let pwm_thre2: u32 =
                                                unsafe {
                                                    ::core::mem::transmute(pwm_thre2)
                                                };
                                            pwm_thre2 as u64
                                        });
            __bindgen_bitfield_unit.set(16usize, 16u8,
                                        {
                                            let reserved_16_31: u32 =
                                                unsafe {
                                                    ::core::mem::transmute(reserved_16_31)
                                                };
                                            reserved_16_31 as u64
                                        });
            __bindgen_bitfield_unit
        }
    }
    impl Default for pwm_reg__bindgen_ty_22 {
        fn default() -> Self { unsafe { ::core::mem::zeroed() } }
    }
    #[repr(C)]
    pub union pwm_reg__bindgen_ty_23 {
        pub BF: pwm_reg__bindgen_ty_23__bindgen_ty_1,
        pub WORD: u32,
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::marker::Copy for pwm_reg__bindgen_ty_23 { }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::clone::Clone for pwm_reg__bindgen_ty_23 {
        #[inline]
        fn clone(&self) -> pwm_reg__bindgen_ty_23 {
            { let _: ::core::clone::AssertParamIsCopy<Self>; *self }
        }
    }
    #[repr(C)]
    #[repr(align(4))]
    pub struct pwm_reg__bindgen_ty_23__bindgen_ty_1 {
        pub _bitfield_align_1: [u16; 0],
        pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::default::Default for pwm_reg__bindgen_ty_23__bindgen_ty_1 {
        #[inline]
        fn default() -> pwm_reg__bindgen_ty_23__bindgen_ty_1 {
            pwm_reg__bindgen_ty_23__bindgen_ty_1{_bitfield_align_1:
                                                     ::core::default::Default::default(),
                                                 _bitfield_1:
                                                     ::core::default::Default::default(),}
        }
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::marker::Copy for pwm_reg__bindgen_ty_23__bindgen_ty_1 { }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::clone::Clone for pwm_reg__bindgen_ty_23__bindgen_ty_1 {
        #[inline]
        fn clone(&self) -> pwm_reg__bindgen_ty_23__bindgen_ty_1 {
            {
                let _: ::core::clone::AssertParamIsClone<[u16; 0]>;
                let _:
                        ::core::clone::AssertParamIsClone<__BindgenBitfieldUnit<[u8; 4usize]>>;
                *self
            }
        }
    }
    impl pwm_reg__bindgen_ty_23__bindgen_ty_1 {
        #[inline]
        pub fn pwm_period(&self) -> u32 {
            unsafe {
                ::core::mem::transmute(self._bitfield_1.get(0usize, 16u8) as
                                           u32)
            }
        }
        #[inline]
        pub fn set_pwm_period(&mut self, val: u32) {
            unsafe {
                let val: u32 = ::core::mem::transmute(val);
                self._bitfield_1.set(0usize, 16u8, val as u64)
            }
        }
        #[inline]
        pub fn reserved_16_31(&self) -> u32 {
            unsafe {
                ::core::mem::transmute(self._bitfield_1.get(16usize, 16u8) as
                                           u32)
            }
        }
        #[inline]
        pub fn set_reserved_16_31(&mut self, val: u32) {
            unsafe {
                let val: u32 = ::core::mem::transmute(val);
                self._bitfield_1.set(16usize, 16u8, val as u64)
            }
        }
        #[inline]
        pub fn new_bitfield_1(pwm_period: u32, reserved_16_31: u32)
         -> __BindgenBitfieldUnit<[u8; 4usize]> {
            let mut __bindgen_bitfield_unit:
                    __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
            __bindgen_bitfield_unit.set(0usize, 16u8,
                                        {
                                            let pwm_period: u32 =
                                                unsafe {
                                                    ::core::mem::transmute(pwm_period)
                                                };
                                            pwm_period as u64
                                        });
            __bindgen_bitfield_unit.set(16usize, 16u8,
                                        {
                                            let reserved_16_31: u32 =
                                                unsafe {
                                                    ::core::mem::transmute(reserved_16_31)
                                                };
                                            reserved_16_31 as u64
                                        });
            __bindgen_bitfield_unit
        }
    }
    impl Default for pwm_reg__bindgen_ty_23 {
        fn default() -> Self { unsafe { ::core::mem::zeroed() } }
    }
    #[repr(C)]
    pub union pwm_reg__bindgen_ty_24 {
        pub BF: pwm_reg__bindgen_ty_24__bindgen_ty_1,
        pub WORD: u32,
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::marker::Copy for pwm_reg__bindgen_ty_24 { }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::clone::Clone for pwm_reg__bindgen_ty_24 {
        #[inline]
        fn clone(&self) -> pwm_reg__bindgen_ty_24 {
            { let _: ::core::clone::AssertParamIsCopy<Self>; *self }
        }
    }
    #[repr(C)]
    #[repr(align(4))]
    pub struct pwm_reg__bindgen_ty_24__bindgen_ty_1 {
        pub _bitfield_align_1: [u32; 0],
        pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::default::Default for pwm_reg__bindgen_ty_24__bindgen_ty_1 {
        #[inline]
        fn default() -> pwm_reg__bindgen_ty_24__bindgen_ty_1 {
            pwm_reg__bindgen_ty_24__bindgen_ty_1{_bitfield_align_1:
                                                     ::core::default::Default::default(),
                                                 _bitfield_1:
                                                     ::core::default::Default::default(),}
        }
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::marker::Copy for pwm_reg__bindgen_ty_24__bindgen_ty_1 { }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::clone::Clone for pwm_reg__bindgen_ty_24__bindgen_ty_1 {
        #[inline]
        fn clone(&self) -> pwm_reg__bindgen_ty_24__bindgen_ty_1 {
            {
                let _: ::core::clone::AssertParamIsClone<[u32; 0]>;
                let _:
                        ::core::clone::AssertParamIsClone<__BindgenBitfieldUnit<[u8; 4usize]>>;
                *self
            }
        }
    }
    impl pwm_reg__bindgen_ty_24__bindgen_ty_1 {
        #[inline]
        pub fn reg_clk_sel(&self) -> u32 {
            unsafe {
                ::core::mem::transmute(self._bitfield_1.get(0usize, 2u8) as
                                           u32)
            }
        }
        #[inline]
        pub fn set_reg_clk_sel(&mut self, val: u32) {
            unsafe {
                let val: u32 = ::core::mem::transmute(val);
                self._bitfield_1.set(0usize, 2u8, val as u64)
            }
        }
        #[inline]
        pub fn pwm_out_inv(&self) -> u32 {
            unsafe {
                ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as
                                           u32)
            }
        }
        #[inline]
        pub fn set_pwm_out_inv(&mut self, val: u32) {
            unsafe {
                let val: u32 = ::core::mem::transmute(val);
                self._bitfield_1.set(2usize, 1u8, val as u64)
            }
        }
        #[inline]
        pub fn pwm_stop_mode(&self) -> u32 {
            unsafe {
                ::core::mem::transmute(self._bitfield_1.get(3usize, 1u8) as
                                           u32)
            }
        }
        #[inline]
        pub fn set_pwm_stop_mode(&mut self, val: u32) {
            unsafe {
                let val: u32 = ::core::mem::transmute(val);
                self._bitfield_1.set(3usize, 1u8, val as u64)
            }
        }
        #[inline]
        pub fn pwm_sw_force_val(&self) -> u32 {
            unsafe {
                ::core::mem::transmute(self._bitfield_1.get(4usize, 1u8) as
                                           u32)
            }
        }
        #[inline]
        pub fn set_pwm_sw_force_val(&mut self, val: u32) {
            unsafe {
                let val: u32 = ::core::mem::transmute(val);
                self._bitfield_1.set(4usize, 1u8, val as u64)
            }
        }
        #[inline]
        pub fn pwm_sw_mode(&self) -> u32 {
            unsafe {
                ::core::mem::transmute(self._bitfield_1.get(5usize, 1u8) as
                                           u32)
            }
        }
        #[inline]
        pub fn set_pwm_sw_mode(&mut self, val: u32) {
            unsafe {
                let val: u32 = ::core::mem::transmute(val);
                self._bitfield_1.set(5usize, 1u8, val as u64)
            }
        }
        #[inline]
        pub fn pwm_stop_en(&self) -> u32 {
            unsafe {
                ::core::mem::transmute(self._bitfield_1.get(6usize, 1u8) as
                                           u32)
            }
        }
        #[inline]
        pub fn set_pwm_stop_en(&mut self, val: u32) {
            unsafe {
                let val: u32 = ::core::mem::transmute(val);
                self._bitfield_1.set(6usize, 1u8, val as u64)
            }
        }
        #[inline]
        pub fn pwm_sts_top(&self) -> u32 {
            unsafe {
                ::core::mem::transmute(self._bitfield_1.get(7usize, 1u8) as
                                           u32)
            }
        }
        #[inline]
        pub fn set_pwm_sts_top(&mut self, val: u32) {
            unsafe {
                let val: u32 = ::core::mem::transmute(val);
                self._bitfield_1.set(7usize, 1u8, val as u64)
            }
        }
        #[inline]
        pub fn reserved_8_31(&self) -> u32 {
            unsafe {
                ::core::mem::transmute(self._bitfield_1.get(8usize, 24u8) as
                                           u32)
            }
        }
        #[inline]
        pub fn set_reserved_8_31(&mut self, val: u32) {
            unsafe {
                let val: u32 = ::core::mem::transmute(val);
                self._bitfield_1.set(8usize, 24u8, val as u64)
            }
        }
        #[inline]
        pub fn new_bitfield_1(reg_clk_sel: u32, pwm_out_inv: u32,
                              pwm_stop_mode: u32, pwm_sw_force_val: u32,
                              pwm_sw_mode: u32, pwm_stop_en: u32,
                              pwm_sts_top: u32, reserved_8_31: u32)
         -> __BindgenBitfieldUnit<[u8; 4usize]> {
            let mut __bindgen_bitfield_unit:
                    __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
            __bindgen_bitfield_unit.set(0usize, 2u8,
                                        {
                                            let reg_clk_sel: u32 =
                                                unsafe {
                                                    ::core::mem::transmute(reg_clk_sel)
                                                };
                                            reg_clk_sel as u64
                                        });
            __bindgen_bitfield_unit.set(2usize, 1u8,
                                        {
                                            let pwm_out_inv: u32 =
                                                unsafe {
                                                    ::core::mem::transmute(pwm_out_inv)
                                                };
                                            pwm_out_inv as u64
                                        });
            __bindgen_bitfield_unit.set(3usize, 1u8,
                                        {
                                            let pwm_stop_mode: u32 =
                                                unsafe {
                                                    ::core::mem::transmute(pwm_stop_mode)
                                                };
                                            pwm_stop_mode as u64
                                        });
            __bindgen_bitfield_unit.set(4usize, 1u8,
                                        {
                                            let pwm_sw_force_val: u32 =
                                                unsafe {
                                                    ::core::mem::transmute(pwm_sw_force_val)
                                                };
                                            pwm_sw_force_val as u64
                                        });
            __bindgen_bitfield_unit.set(5usize, 1u8,
                                        {
                                            let pwm_sw_mode: u32 =
                                                unsafe {
                                                    ::core::mem::transmute(pwm_sw_mode)
                                                };
                                            pwm_sw_mode as u64
                                        });
            __bindgen_bitfield_unit.set(6usize, 1u8,
                                        {
                                            let pwm_stop_en: u32 =
                                                unsafe {
                                                    ::core::mem::transmute(pwm_stop_en)
                                                };
                                            pwm_stop_en as u64
                                        });
            __bindgen_bitfield_unit.set(7usize, 1u8,
                                        {
                                            let pwm_sts_top: u32 =
                                                unsafe {
                                                    ::core::mem::transmute(pwm_sts_top)
                                                };
                                            pwm_sts_top as u64
                                        });
            __bindgen_bitfield_unit.set(8usize, 24u8,
                                        {
                                            let reserved_8_31: u32 =
                                                unsafe {
                                                    ::core::mem::transmute(reserved_8_31)
                                                };
                                            reserved_8_31 as u64
                                        });
            __bindgen_bitfield_unit
        }
    }
    impl Default for pwm_reg__bindgen_ty_24 {
        fn default() -> Self { unsafe { ::core::mem::zeroed() } }
    }
    #[repr(C)]
    pub union pwm_reg__bindgen_ty_25 {
        pub BF: pwm_reg__bindgen_ty_25__bindgen_ty_1,
        pub WORD: u32,
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::marker::Copy for pwm_reg__bindgen_ty_25 { }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::clone::Clone for pwm_reg__bindgen_ty_25 {
        #[inline]
        fn clone(&self) -> pwm_reg__bindgen_ty_25 {
            { let _: ::core::clone::AssertParamIsCopy<Self>; *self }
        }
    }
    #[repr(C)]
    #[repr(align(4))]
    pub struct pwm_reg__bindgen_ty_25__bindgen_ty_1 {
        pub _bitfield_align_1: [u16; 0],
        pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::default::Default for pwm_reg__bindgen_ty_25__bindgen_ty_1 {
        #[inline]
        fn default() -> pwm_reg__bindgen_ty_25__bindgen_ty_1 {
            pwm_reg__bindgen_ty_25__bindgen_ty_1{_bitfield_align_1:
                                                     ::core::default::Default::default(),
                                                 _bitfield_1:
                                                     ::core::default::Default::default(),}
        }
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::marker::Copy for pwm_reg__bindgen_ty_25__bindgen_ty_1 { }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::clone::Clone for pwm_reg__bindgen_ty_25__bindgen_ty_1 {
        #[inline]
        fn clone(&self) -> pwm_reg__bindgen_ty_25__bindgen_ty_1 {
            {
                let _: ::core::clone::AssertParamIsClone<[u16; 0]>;
                let _:
                        ::core::clone::AssertParamIsClone<__BindgenBitfieldUnit<[u8; 4usize]>>;
                *self
            }
        }
    }
    impl pwm_reg__bindgen_ty_25__bindgen_ty_1 {
        #[inline]
        pub fn pwm_int_period_cnt(&self) -> u32 {
            unsafe {
                ::core::mem::transmute(self._bitfield_1.get(0usize, 16u8) as
                                           u32)
            }
        }
        #[inline]
        pub fn set_pwm_int_period_cnt(&mut self, val: u32) {
            unsafe {
                let val: u32 = ::core::mem::transmute(val);
                self._bitfield_1.set(0usize, 16u8, val as u64)
            }
        }
        #[inline]
        pub fn pwm_int_enable(&self) -> u32 {
            unsafe {
                ::core::mem::transmute(self._bitfield_1.get(16usize, 1u8) as
                                           u32)
            }
        }
        #[inline]
        pub fn set_pwm_int_enable(&mut self, val: u32) {
            unsafe {
                let val: u32 = ::core::mem::transmute(val);
                self._bitfield_1.set(16usize, 1u8, val as u64)
            }
        }
        #[inline]
        pub fn reserved_17_31(&self) -> u32 {
            unsafe {
                ::core::mem::transmute(self._bitfield_1.get(17usize, 15u8) as
                                           u32)
            }
        }
        #[inline]
        pub fn set_reserved_17_31(&mut self, val: u32) {
            unsafe {
                let val: u32 = ::core::mem::transmute(val);
                self._bitfield_1.set(17usize, 15u8, val as u64)
            }
        }
        #[inline]
        pub fn new_bitfield_1(pwm_int_period_cnt: u32, pwm_int_enable: u32,
                              reserved_17_31: u32)
         -> __BindgenBitfieldUnit<[u8; 4usize]> {
            let mut __bindgen_bitfield_unit:
                    __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
            __bindgen_bitfield_unit.set(0usize, 16u8,
                                        {
                                            let pwm_int_period_cnt: u32 =
                                                unsafe {
                                                    ::core::mem::transmute(pwm_int_period_cnt)
                                                };
                                            pwm_int_period_cnt as u64
                                        });
            __bindgen_bitfield_unit.set(16usize, 1u8,
                                        {
                                            let pwm_int_enable: u32 =
                                                unsafe {
                                                    ::core::mem::transmute(pwm_int_enable)
                                                };
                                            pwm_int_enable as u64
                                        });
            __bindgen_bitfield_unit.set(17usize, 15u8,
                                        {
                                            let reserved_17_31: u32 =
                                                unsafe {
                                                    ::core::mem::transmute(reserved_17_31)
                                                };
                                            reserved_17_31 as u64
                                        });
            __bindgen_bitfield_unit
        }
    }
    impl Default for pwm_reg__bindgen_ty_25 {
        fn default() -> Self { unsafe { ::core::mem::zeroed() } }
    }
    #[repr(C)]
    pub union pwm_reg__bindgen_ty_26 {
        pub BF: pwm_reg__bindgen_ty_26__bindgen_ty_1,
        pub WORD: u32,
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::marker::Copy for pwm_reg__bindgen_ty_26 { }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::clone::Clone for pwm_reg__bindgen_ty_26 {
        #[inline]
        fn clone(&self) -> pwm_reg__bindgen_ty_26 {
            { let _: ::core::clone::AssertParamIsCopy<Self>; *self }
        }
    }
    #[repr(C)]
    #[repr(align(4))]
    pub struct pwm_reg__bindgen_ty_26__bindgen_ty_1 {
        pub _bitfield_align_1: [u16; 0],
        pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::default::Default for pwm_reg__bindgen_ty_26__bindgen_ty_1 {
        #[inline]
        fn default() -> pwm_reg__bindgen_ty_26__bindgen_ty_1 {
            pwm_reg__bindgen_ty_26__bindgen_ty_1{_bitfield_align_1:
                                                     ::core::default::Default::default(),
                                                 _bitfield_1:
                                                     ::core::default::Default::default(),}
        }
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::marker::Copy for pwm_reg__bindgen_ty_26__bindgen_ty_1 { }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::clone::Clone for pwm_reg__bindgen_ty_26__bindgen_ty_1 {
        #[inline]
        fn clone(&self) -> pwm_reg__bindgen_ty_26__bindgen_ty_1 {
            {
                let _: ::core::clone::AssertParamIsClone<[u16; 0]>;
                let _:
                        ::core::clone::AssertParamIsClone<__BindgenBitfieldUnit<[u8; 4usize]>>;
                *self
            }
        }
    }
    impl pwm_reg__bindgen_ty_26__bindgen_ty_1 {
        #[inline]
        pub fn pwm_clk_div(&self) -> u32 {
            unsafe {
                ::core::mem::transmute(self._bitfield_1.get(0usize, 16u8) as
                                           u32)
            }
        }
        #[inline]
        pub fn set_pwm_clk_div(&mut self, val: u32) {
            unsafe {
                let val: u32 = ::core::mem::transmute(val);
                self._bitfield_1.set(0usize, 16u8, val as u64)
            }
        }
        #[inline]
        pub fn reserved_16_31(&self) -> u32 {
            unsafe {
                ::core::mem::transmute(self._bitfield_1.get(16usize, 16u8) as
                                           u32)
            }
        }
        #[inline]
        pub fn set_reserved_16_31(&mut self, val: u32) {
            unsafe {
                let val: u32 = ::core::mem::transmute(val);
                self._bitfield_1.set(16usize, 16u8, val as u64)
            }
        }
        #[inline]
        pub fn new_bitfield_1(pwm_clk_div: u32, reserved_16_31: u32)
         -> __BindgenBitfieldUnit<[u8; 4usize]> {
            let mut __bindgen_bitfield_unit:
                    __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
            __bindgen_bitfield_unit.set(0usize, 16u8,
                                        {
                                            let pwm_clk_div: u32 =
                                                unsafe {
                                                    ::core::mem::transmute(pwm_clk_div)
                                                };
                                            pwm_clk_div as u64
                                        });
            __bindgen_bitfield_unit.set(16usize, 16u8,
                                        {
                                            let reserved_16_31: u32 =
                                                unsafe {
                                                    ::core::mem::transmute(reserved_16_31)
                                                };
                                            reserved_16_31 as u64
                                        });
            __bindgen_bitfield_unit
        }
    }
    impl Default for pwm_reg__bindgen_ty_26 {
        fn default() -> Self { unsafe { ::core::mem::zeroed() } }
    }
    #[repr(C)]
    pub union pwm_reg__bindgen_ty_27 {
        pub BF: pwm_reg__bindgen_ty_27__bindgen_ty_1,
        pub WORD: u32,
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::marker::Copy for pwm_reg__bindgen_ty_27 { }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::clone::Clone for pwm_reg__bindgen_ty_27 {
        #[inline]
        fn clone(&self) -> pwm_reg__bindgen_ty_27 {
            { let _: ::core::clone::AssertParamIsCopy<Self>; *self }
        }
    }
    #[repr(C)]
    #[repr(align(4))]
    pub struct pwm_reg__bindgen_ty_27__bindgen_ty_1 {
        pub _bitfield_align_1: [u16; 0],
        pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::default::Default for pwm_reg__bindgen_ty_27__bindgen_ty_1 {
        #[inline]
        fn default() -> pwm_reg__bindgen_ty_27__bindgen_ty_1 {
            pwm_reg__bindgen_ty_27__bindgen_ty_1{_bitfield_align_1:
                                                     ::core::default::Default::default(),
                                                 _bitfield_1:
                                                     ::core::default::Default::default(),}
        }
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::marker::Copy for pwm_reg__bindgen_ty_27__bindgen_ty_1 { }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::clone::Clone for pwm_reg__bindgen_ty_27__bindgen_ty_1 {
        #[inline]
        fn clone(&self) -> pwm_reg__bindgen_ty_27__bindgen_ty_1 {
            {
                let _: ::core::clone::AssertParamIsClone<[u16; 0]>;
                let _:
                        ::core::clone::AssertParamIsClone<__BindgenBitfieldUnit<[u8; 4usize]>>;
                *self
            }
        }
    }
    impl pwm_reg__bindgen_ty_27__bindgen_ty_1 {
        #[inline]
        pub fn pwm_thre1(&self) -> u32 {
            unsafe {
                ::core::mem::transmute(self._bitfield_1.get(0usize, 16u8) as
                                           u32)
            }
        }
        #[inline]
        pub fn set_pwm_thre1(&mut self, val: u32) {
            unsafe {
                let val: u32 = ::core::mem::transmute(val);
                self._bitfield_1.set(0usize, 16u8, val as u64)
            }
        }
        #[inline]
        pub fn reserved_16_31(&self) -> u32 {
            unsafe {
                ::core::mem::transmute(self._bitfield_1.get(16usize, 16u8) as
                                           u32)
            }
        }
        #[inline]
        pub fn set_reserved_16_31(&mut self, val: u32) {
            unsafe {
                let val: u32 = ::core::mem::transmute(val);
                self._bitfield_1.set(16usize, 16u8, val as u64)
            }
        }
        #[inline]
        pub fn new_bitfield_1(pwm_thre1: u32, reserved_16_31: u32)
         -> __BindgenBitfieldUnit<[u8; 4usize]> {
            let mut __bindgen_bitfield_unit:
                    __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
            __bindgen_bitfield_unit.set(0usize, 16u8,
                                        {
                                            let pwm_thre1: u32 =
                                                unsafe {
                                                    ::core::mem::transmute(pwm_thre1)
                                                };
                                            pwm_thre1 as u64
                                        });
            __bindgen_bitfield_unit.set(16usize, 16u8,
                                        {
                                            let reserved_16_31: u32 =
                                                unsafe {
                                                    ::core::mem::transmute(reserved_16_31)
                                                };
                                            reserved_16_31 as u64
                                        });
            __bindgen_bitfield_unit
        }
    }
    impl Default for pwm_reg__bindgen_ty_27 {
        fn default() -> Self { unsafe { ::core::mem::zeroed() } }
    }
    #[repr(C)]
    pub union pwm_reg__bindgen_ty_28 {
        pub BF: pwm_reg__bindgen_ty_28__bindgen_ty_1,
        pub WORD: u32,
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::marker::Copy for pwm_reg__bindgen_ty_28 { }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::clone::Clone for pwm_reg__bindgen_ty_28 {
        #[inline]
        fn clone(&self) -> pwm_reg__bindgen_ty_28 {
            { let _: ::core::clone::AssertParamIsCopy<Self>; *self }
        }
    }
    #[repr(C)]
    #[repr(align(4))]
    pub struct pwm_reg__bindgen_ty_28__bindgen_ty_1 {
        pub _bitfield_align_1: [u16; 0],
        pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::default::Default for pwm_reg__bindgen_ty_28__bindgen_ty_1 {
        #[inline]
        fn default() -> pwm_reg__bindgen_ty_28__bindgen_ty_1 {
            pwm_reg__bindgen_ty_28__bindgen_ty_1{_bitfield_align_1:
                                                     ::core::default::Default::default(),
                                                 _bitfield_1:
                                                     ::core::default::Default::default(),}
        }
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::marker::Copy for pwm_reg__bindgen_ty_28__bindgen_ty_1 { }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::clone::Clone for pwm_reg__bindgen_ty_28__bindgen_ty_1 {
        #[inline]
        fn clone(&self) -> pwm_reg__bindgen_ty_28__bindgen_ty_1 {
            {
                let _: ::core::clone::AssertParamIsClone<[u16; 0]>;
                let _:
                        ::core::clone::AssertParamIsClone<__BindgenBitfieldUnit<[u8; 4usize]>>;
                *self
            }
        }
    }
    impl pwm_reg__bindgen_ty_28__bindgen_ty_1 {
        #[inline]
        pub fn pwm_thre2(&self) -> u32 {
            unsafe {
                ::core::mem::transmute(self._bitfield_1.get(0usize, 16u8) as
                                           u32)
            }
        }
        #[inline]
        pub fn set_pwm_thre2(&mut self, val: u32) {
            unsafe {
                let val: u32 = ::core::mem::transmute(val);
                self._bitfield_1.set(0usize, 16u8, val as u64)
            }
        }
        #[inline]
        pub fn reserved_16_31(&self) -> u32 {
            unsafe {
                ::core::mem::transmute(self._bitfield_1.get(16usize, 16u8) as
                                           u32)
            }
        }
        #[inline]
        pub fn set_reserved_16_31(&mut self, val: u32) {
            unsafe {
                let val: u32 = ::core::mem::transmute(val);
                self._bitfield_1.set(16usize, 16u8, val as u64)
            }
        }
        #[inline]
        pub fn new_bitfield_1(pwm_thre2: u32, reserved_16_31: u32)
         -> __BindgenBitfieldUnit<[u8; 4usize]> {
            let mut __bindgen_bitfield_unit:
                    __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
            __bindgen_bitfield_unit.set(0usize, 16u8,
                                        {
                                            let pwm_thre2: u32 =
                                                unsafe {
                                                    ::core::mem::transmute(pwm_thre2)
                                                };
                                            pwm_thre2 as u64
                                        });
            __bindgen_bitfield_unit.set(16usize, 16u8,
                                        {
                                            let reserved_16_31: u32 =
                                                unsafe {
                                                    ::core::mem::transmute(reserved_16_31)
                                                };
                                            reserved_16_31 as u64
                                        });
            __bindgen_bitfield_unit
        }
    }
    impl Default for pwm_reg__bindgen_ty_28 {
        fn default() -> Self { unsafe { ::core::mem::zeroed() } }
    }
    #[repr(C)]
    pub union pwm_reg__bindgen_ty_29 {
        pub BF: pwm_reg__bindgen_ty_29__bindgen_ty_1,
        pub WORD: u32,
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::marker::Copy for pwm_reg__bindgen_ty_29 { }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::clone::Clone for pwm_reg__bindgen_ty_29 {
        #[inline]
        fn clone(&self) -> pwm_reg__bindgen_ty_29 {
            { let _: ::core::clone::AssertParamIsCopy<Self>; *self }
        }
    }
    #[repr(C)]
    #[repr(align(4))]
    pub struct pwm_reg__bindgen_ty_29__bindgen_ty_1 {
        pub _bitfield_align_1: [u16; 0],
        pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::default::Default for pwm_reg__bindgen_ty_29__bindgen_ty_1 {
        #[inline]
        fn default() -> pwm_reg__bindgen_ty_29__bindgen_ty_1 {
            pwm_reg__bindgen_ty_29__bindgen_ty_1{_bitfield_align_1:
                                                     ::core::default::Default::default(),
                                                 _bitfield_1:
                                                     ::core::default::Default::default(),}
        }
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::marker::Copy for pwm_reg__bindgen_ty_29__bindgen_ty_1 { }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::clone::Clone for pwm_reg__bindgen_ty_29__bindgen_ty_1 {
        #[inline]
        fn clone(&self) -> pwm_reg__bindgen_ty_29__bindgen_ty_1 {
            {
                let _: ::core::clone::AssertParamIsClone<[u16; 0]>;
                let _:
                        ::core::clone::AssertParamIsClone<__BindgenBitfieldUnit<[u8; 4usize]>>;
                *self
            }
        }
    }
    impl pwm_reg__bindgen_ty_29__bindgen_ty_1 {
        #[inline]
        pub fn pwm_period(&self) -> u32 {
            unsafe {
                ::core::mem::transmute(self._bitfield_1.get(0usize, 16u8) as
                                           u32)
            }
        }
        #[inline]
        pub fn set_pwm_period(&mut self, val: u32) {
            unsafe {
                let val: u32 = ::core::mem::transmute(val);
                self._bitfield_1.set(0usize, 16u8, val as u64)
            }
        }
        #[inline]
        pub fn reserved_16_31(&self) -> u32 {
            unsafe {
                ::core::mem::transmute(self._bitfield_1.get(16usize, 16u8) as
                                           u32)
            }
        }
        #[inline]
        pub fn set_reserved_16_31(&mut self, val: u32) {
            unsafe {
                let val: u32 = ::core::mem::transmute(val);
                self._bitfield_1.set(16usize, 16u8, val as u64)
            }
        }
        #[inline]
        pub fn new_bitfield_1(pwm_period: u32, reserved_16_31: u32)
         -> __BindgenBitfieldUnit<[u8; 4usize]> {
            let mut __bindgen_bitfield_unit:
                    __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
            __bindgen_bitfield_unit.set(0usize, 16u8,
                                        {
                                            let pwm_period: u32 =
                                                unsafe {
                                                    ::core::mem::transmute(pwm_period)
                                                };
                                            pwm_period as u64
                                        });
            __bindgen_bitfield_unit.set(16usize, 16u8,
                                        {
                                            let reserved_16_31: u32 =
                                                unsafe {
                                                    ::core::mem::transmute(reserved_16_31)
                                                };
                                            reserved_16_31 as u64
                                        });
            __bindgen_bitfield_unit
        }
    }
    impl Default for pwm_reg__bindgen_ty_29 {
        fn default() -> Self { unsafe { ::core::mem::zeroed() } }
    }
    #[repr(C)]
    pub union pwm_reg__bindgen_ty_30 {
        pub BF: pwm_reg__bindgen_ty_30__bindgen_ty_1,
        pub WORD: u32,
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::marker::Copy for pwm_reg__bindgen_ty_30 { }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::clone::Clone for pwm_reg__bindgen_ty_30 {
        #[inline]
        fn clone(&self) -> pwm_reg__bindgen_ty_30 {
            { let _: ::core::clone::AssertParamIsCopy<Self>; *self }
        }
    }
    #[repr(C)]
    #[repr(align(4))]
    pub struct pwm_reg__bindgen_ty_30__bindgen_ty_1 {
        pub _bitfield_align_1: [u32; 0],
        pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::default::Default for pwm_reg__bindgen_ty_30__bindgen_ty_1 {
        #[inline]
        fn default() -> pwm_reg__bindgen_ty_30__bindgen_ty_1 {
            pwm_reg__bindgen_ty_30__bindgen_ty_1{_bitfield_align_1:
                                                     ::core::default::Default::default(),
                                                 _bitfield_1:
                                                     ::core::default::Default::default(),}
        }
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::marker::Copy for pwm_reg__bindgen_ty_30__bindgen_ty_1 { }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::clone::Clone for pwm_reg__bindgen_ty_30__bindgen_ty_1 {
        #[inline]
        fn clone(&self) -> pwm_reg__bindgen_ty_30__bindgen_ty_1 {
            {
                let _: ::core::clone::AssertParamIsClone<[u32; 0]>;
                let _:
                        ::core::clone::AssertParamIsClone<__BindgenBitfieldUnit<[u8; 4usize]>>;
                *self
            }
        }
    }
    impl pwm_reg__bindgen_ty_30__bindgen_ty_1 {
        #[inline]
        pub fn reg_clk_sel(&self) -> u32 {
            unsafe {
                ::core::mem::transmute(self._bitfield_1.get(0usize, 2u8) as
                                           u32)
            }
        }
        #[inline]
        pub fn set_reg_clk_sel(&mut self, val: u32) {
            unsafe {
                let val: u32 = ::core::mem::transmute(val);
                self._bitfield_1.set(0usize, 2u8, val as u64)
            }
        }
        #[inline]
        pub fn pwm_out_inv(&self) -> u32 {
            unsafe {
                ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as
                                           u32)
            }
        }
        #[inline]
        pub fn set_pwm_out_inv(&mut self, val: u32) {
            unsafe {
                let val: u32 = ::core::mem::transmute(val);
                self._bitfield_1.set(2usize, 1u8, val as u64)
            }
        }
        #[inline]
        pub fn pwm_stop_mode(&self) -> u32 {
            unsafe {
                ::core::mem::transmute(self._bitfield_1.get(3usize, 1u8) as
                                           u32)
            }
        }
        #[inline]
        pub fn set_pwm_stop_mode(&mut self, val: u32) {
            unsafe {
                let val: u32 = ::core::mem::transmute(val);
                self._bitfield_1.set(3usize, 1u8, val as u64)
            }
        }
        #[inline]
        pub fn pwm_sw_force_val(&self) -> u32 {
            unsafe {
                ::core::mem::transmute(self._bitfield_1.get(4usize, 1u8) as
                                           u32)
            }
        }
        #[inline]
        pub fn set_pwm_sw_force_val(&mut self, val: u32) {
            unsafe {
                let val: u32 = ::core::mem::transmute(val);
                self._bitfield_1.set(4usize, 1u8, val as u64)
            }
        }
        #[inline]
        pub fn pwm_sw_mode(&self) -> u32 {
            unsafe {
                ::core::mem::transmute(self._bitfield_1.get(5usize, 1u8) as
                                           u32)
            }
        }
        #[inline]
        pub fn set_pwm_sw_mode(&mut self, val: u32) {
            unsafe {
                let val: u32 = ::core::mem::transmute(val);
                self._bitfield_1.set(5usize, 1u8, val as u64)
            }
        }
        #[inline]
        pub fn pwm_stop_en(&self) -> u32 {
            unsafe {
                ::core::mem::transmute(self._bitfield_1.get(6usize, 1u8) as
                                           u32)
            }
        }
        #[inline]
        pub fn set_pwm_stop_en(&mut self, val: u32) {
            unsafe {
                let val: u32 = ::core::mem::transmute(val);
                self._bitfield_1.set(6usize, 1u8, val as u64)
            }
        }
        #[inline]
        pub fn pwm_sts_top(&self) -> u32 {
            unsafe {
                ::core::mem::transmute(self._bitfield_1.get(7usize, 1u8) as
                                           u32)
            }
        }
        #[inline]
        pub fn set_pwm_sts_top(&mut self, val: u32) {
            unsafe {
                let val: u32 = ::core::mem::transmute(val);
                self._bitfield_1.set(7usize, 1u8, val as u64)
            }
        }
        #[inline]
        pub fn reserved_8_31(&self) -> u32 {
            unsafe {
                ::core::mem::transmute(self._bitfield_1.get(8usize, 24u8) as
                                           u32)
            }
        }
        #[inline]
        pub fn set_reserved_8_31(&mut self, val: u32) {
            unsafe {
                let val: u32 = ::core::mem::transmute(val);
                self._bitfield_1.set(8usize, 24u8, val as u64)
            }
        }
        #[inline]
        pub fn new_bitfield_1(reg_clk_sel: u32, pwm_out_inv: u32,
                              pwm_stop_mode: u32, pwm_sw_force_val: u32,
                              pwm_sw_mode: u32, pwm_stop_en: u32,
                              pwm_sts_top: u32, reserved_8_31: u32)
         -> __BindgenBitfieldUnit<[u8; 4usize]> {
            let mut __bindgen_bitfield_unit:
                    __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
            __bindgen_bitfield_unit.set(0usize, 2u8,
                                        {
                                            let reg_clk_sel: u32 =
                                                unsafe {
                                                    ::core::mem::transmute(reg_clk_sel)
                                                };
                                            reg_clk_sel as u64
                                        });
            __bindgen_bitfield_unit.set(2usize, 1u8,
                                        {
                                            let pwm_out_inv: u32 =
                                                unsafe {
                                                    ::core::mem::transmute(pwm_out_inv)
                                                };
                                            pwm_out_inv as u64
                                        });
            __bindgen_bitfield_unit.set(3usize, 1u8,
                                        {
                                            let pwm_stop_mode: u32 =
                                                unsafe {
                                                    ::core::mem::transmute(pwm_stop_mode)
                                                };
                                            pwm_stop_mode as u64
                                        });
            __bindgen_bitfield_unit.set(4usize, 1u8,
                                        {
                                            let pwm_sw_force_val: u32 =
                                                unsafe {
                                                    ::core::mem::transmute(pwm_sw_force_val)
                                                };
                                            pwm_sw_force_val as u64
                                        });
            __bindgen_bitfield_unit.set(5usize, 1u8,
                                        {
                                            let pwm_sw_mode: u32 =
                                                unsafe {
                                                    ::core::mem::transmute(pwm_sw_mode)
                                                };
                                            pwm_sw_mode as u64
                                        });
            __bindgen_bitfield_unit.set(6usize, 1u8,
                                        {
                                            let pwm_stop_en: u32 =
                                                unsafe {
                                                    ::core::mem::transmute(pwm_stop_en)
                                                };
                                            pwm_stop_en as u64
                                        });
            __bindgen_bitfield_unit.set(7usize, 1u8,
                                        {
                                            let pwm_sts_top: u32 =
                                                unsafe {
                                                    ::core::mem::transmute(pwm_sts_top)
                                                };
                                            pwm_sts_top as u64
                                        });
            __bindgen_bitfield_unit.set(8usize, 24u8,
                                        {
                                            let reserved_8_31: u32 =
                                                unsafe {
                                                    ::core::mem::transmute(reserved_8_31)
                                                };
                                            reserved_8_31 as u64
                                        });
            __bindgen_bitfield_unit
        }
    }
    impl Default for pwm_reg__bindgen_ty_30 {
        fn default() -> Self { unsafe { ::core::mem::zeroed() } }
    }
    #[repr(C)]
    pub union pwm_reg__bindgen_ty_31 {
        pub BF: pwm_reg__bindgen_ty_31__bindgen_ty_1,
        pub WORD: u32,
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::marker::Copy for pwm_reg__bindgen_ty_31 { }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::clone::Clone for pwm_reg__bindgen_ty_31 {
        #[inline]
        fn clone(&self) -> pwm_reg__bindgen_ty_31 {
            { let _: ::core::clone::AssertParamIsCopy<Self>; *self }
        }
    }
    #[repr(C)]
    #[repr(align(4))]
    pub struct pwm_reg__bindgen_ty_31__bindgen_ty_1 {
        pub _bitfield_align_1: [u16; 0],
        pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::default::Default for pwm_reg__bindgen_ty_31__bindgen_ty_1 {
        #[inline]
        fn default() -> pwm_reg__bindgen_ty_31__bindgen_ty_1 {
            pwm_reg__bindgen_ty_31__bindgen_ty_1{_bitfield_align_1:
                                                     ::core::default::Default::default(),
                                                 _bitfield_1:
                                                     ::core::default::Default::default(),}
        }
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::marker::Copy for pwm_reg__bindgen_ty_31__bindgen_ty_1 { }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::clone::Clone for pwm_reg__bindgen_ty_31__bindgen_ty_1 {
        #[inline]
        fn clone(&self) -> pwm_reg__bindgen_ty_31__bindgen_ty_1 {
            {
                let _: ::core::clone::AssertParamIsClone<[u16; 0]>;
                let _:
                        ::core::clone::AssertParamIsClone<__BindgenBitfieldUnit<[u8; 4usize]>>;
                *self
            }
        }
    }
    impl pwm_reg__bindgen_ty_31__bindgen_ty_1 {
        #[inline]
        pub fn pwm_int_period_cnt(&self) -> u32 {
            unsafe {
                ::core::mem::transmute(self._bitfield_1.get(0usize, 16u8) as
                                           u32)
            }
        }
        #[inline]
        pub fn set_pwm_int_period_cnt(&mut self, val: u32) {
            unsafe {
                let val: u32 = ::core::mem::transmute(val);
                self._bitfield_1.set(0usize, 16u8, val as u64)
            }
        }
        #[inline]
        pub fn pwm_int_enable(&self) -> u32 {
            unsafe {
                ::core::mem::transmute(self._bitfield_1.get(16usize, 1u8) as
                                           u32)
            }
        }
        #[inline]
        pub fn set_pwm_int_enable(&mut self, val: u32) {
            unsafe {
                let val: u32 = ::core::mem::transmute(val);
                self._bitfield_1.set(16usize, 1u8, val as u64)
            }
        }
        #[inline]
        pub fn reserved_17_31(&self) -> u32 {
            unsafe {
                ::core::mem::transmute(self._bitfield_1.get(17usize, 15u8) as
                                           u32)
            }
        }
        #[inline]
        pub fn set_reserved_17_31(&mut self, val: u32) {
            unsafe {
                let val: u32 = ::core::mem::transmute(val);
                self._bitfield_1.set(17usize, 15u8, val as u64)
            }
        }
        #[inline]
        pub fn new_bitfield_1(pwm_int_period_cnt: u32, pwm_int_enable: u32,
                              reserved_17_31: u32)
         -> __BindgenBitfieldUnit<[u8; 4usize]> {
            let mut __bindgen_bitfield_unit:
                    __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
            __bindgen_bitfield_unit.set(0usize, 16u8,
                                        {
                                            let pwm_int_period_cnt: u32 =
                                                unsafe {
                                                    ::core::mem::transmute(pwm_int_period_cnt)
                                                };
                                            pwm_int_period_cnt as u64
                                        });
            __bindgen_bitfield_unit.set(16usize, 1u8,
                                        {
                                            let pwm_int_enable: u32 =
                                                unsafe {
                                                    ::core::mem::transmute(pwm_int_enable)
                                                };
                                            pwm_int_enable as u64
                                        });
            __bindgen_bitfield_unit.set(17usize, 15u8,
                                        {
                                            let reserved_17_31: u32 =
                                                unsafe {
                                                    ::core::mem::transmute(reserved_17_31)
                                                };
                                            reserved_17_31 as u64
                                        });
            __bindgen_bitfield_unit
        }
    }
    impl Default for pwm_reg__bindgen_ty_31 {
        fn default() -> Self { unsafe { ::core::mem::zeroed() } }
    }
    impl Default for pwm_reg {
        fn default() -> Self { unsafe { ::core::mem::zeroed() } }
    }
    pub type pwm_reg_t = pwm_reg;
    #[repr(C)]
    pub struct pwm_channel_reg {
        pub pwm_clkdiv: pwm_channel_reg__bindgen_ty_1,
        pub pwm_thre1: pwm_channel_reg__bindgen_ty_2,
        pub pwm_thre2: pwm_channel_reg__bindgen_ty_3,
        pub pwm_period: pwm_channel_reg__bindgen_ty_4,
        pub pwm_config: pwm_channel_reg__bindgen_ty_5,
        pub pwm_interrupt: pwm_channel_reg__bindgen_ty_6,
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::marker::Copy for pwm_channel_reg { }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::clone::Clone for pwm_channel_reg {
        #[inline]
        fn clone(&self) -> pwm_channel_reg {
            {
                let _:
                        ::core::clone::AssertParamIsClone<pwm_channel_reg__bindgen_ty_1>;
                let _:
                        ::core::clone::AssertParamIsClone<pwm_channel_reg__bindgen_ty_2>;
                let _:
                        ::core::clone::AssertParamIsClone<pwm_channel_reg__bindgen_ty_3>;
                let _:
                        ::core::clone::AssertParamIsClone<pwm_channel_reg__bindgen_ty_4>;
                let _:
                        ::core::clone::AssertParamIsClone<pwm_channel_reg__bindgen_ty_5>;
                let _:
                        ::core::clone::AssertParamIsClone<pwm_channel_reg__bindgen_ty_6>;
                *self
            }
        }
    }
    #[repr(C)]
    pub union pwm_channel_reg__bindgen_ty_1 {
        pub BF: pwm_channel_reg__bindgen_ty_1__bindgen_ty_1,
        pub WORD: u32,
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::marker::Copy for pwm_channel_reg__bindgen_ty_1 { }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::clone::Clone for pwm_channel_reg__bindgen_ty_1 {
        #[inline]
        fn clone(&self) -> pwm_channel_reg__bindgen_ty_1 {
            { let _: ::core::clone::AssertParamIsCopy<Self>; *self }
        }
    }
    #[repr(C)]
    #[repr(align(4))]
    pub struct pwm_channel_reg__bindgen_ty_1__bindgen_ty_1 {
        pub _bitfield_align_1: [u16; 0],
        pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::default::Default for
     pwm_channel_reg__bindgen_ty_1__bindgen_ty_1 {
        #[inline]
        fn default() -> pwm_channel_reg__bindgen_ty_1__bindgen_ty_1 {
            pwm_channel_reg__bindgen_ty_1__bindgen_ty_1{_bitfield_align_1:
                                                            ::core::default::Default::default(),
                                                        _bitfield_1:
                                                            ::core::default::Default::default(),}
        }
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::marker::Copy for pwm_channel_reg__bindgen_ty_1__bindgen_ty_1
     {
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::clone::Clone for pwm_channel_reg__bindgen_ty_1__bindgen_ty_1
     {
        #[inline]
        fn clone(&self) -> pwm_channel_reg__bindgen_ty_1__bindgen_ty_1 {
            {
                let _: ::core::clone::AssertParamIsClone<[u16; 0]>;
                let _:
                        ::core::clone::AssertParamIsClone<__BindgenBitfieldUnit<[u8; 4usize]>>;
                *self
            }
        }
    }
    impl pwm_channel_reg__bindgen_ty_1__bindgen_ty_1 {
        #[inline]
        pub fn pwm_clk_div(&self) -> u32 {
            unsafe {
                ::core::mem::transmute(self._bitfield_1.get(0usize, 16u8) as
                                           u32)
            }
        }
        #[inline]
        pub fn set_pwm_clk_div(&mut self, val: u32) {
            unsafe {
                let val: u32 = ::core::mem::transmute(val);
                self._bitfield_1.set(0usize, 16u8, val as u64)
            }
        }
        #[inline]
        pub fn reserved_16_31(&self) -> u32 {
            unsafe {
                ::core::mem::transmute(self._bitfield_1.get(16usize, 16u8) as
                                           u32)
            }
        }
        #[inline]
        pub fn set_reserved_16_31(&mut self, val: u32) {
            unsafe {
                let val: u32 = ::core::mem::transmute(val);
                self._bitfield_1.set(16usize, 16u8, val as u64)
            }
        }
        #[inline]
        pub fn new_bitfield_1(pwm_clk_div: u32, reserved_16_31: u32)
         -> __BindgenBitfieldUnit<[u8; 4usize]> {
            let mut __bindgen_bitfield_unit:
                    __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
            __bindgen_bitfield_unit.set(0usize, 16u8,
                                        {
                                            let pwm_clk_div: u32 =
                                                unsafe {
                                                    ::core::mem::transmute(pwm_clk_div)
                                                };
                                            pwm_clk_div as u64
                                        });
            __bindgen_bitfield_unit.set(16usize, 16u8,
                                        {
                                            let reserved_16_31: u32 =
                                                unsafe {
                                                    ::core::mem::transmute(reserved_16_31)
                                                };
                                            reserved_16_31 as u64
                                        });
            __bindgen_bitfield_unit
        }
    }
    impl Default for pwm_channel_reg__bindgen_ty_1 {
        fn default() -> Self { unsafe { ::core::mem::zeroed() } }
    }
    #[repr(C)]
    pub union pwm_channel_reg__bindgen_ty_2 {
        pub BF: pwm_channel_reg__bindgen_ty_2__bindgen_ty_1,
        pub WORD: u32,
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::marker::Copy for pwm_channel_reg__bindgen_ty_2 { }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::clone::Clone for pwm_channel_reg__bindgen_ty_2 {
        #[inline]
        fn clone(&self) -> pwm_channel_reg__bindgen_ty_2 {
            { let _: ::core::clone::AssertParamIsCopy<Self>; *self }
        }
    }
    #[repr(C)]
    #[repr(align(4))]
    pub struct pwm_channel_reg__bindgen_ty_2__bindgen_ty_1 {
        pub _bitfield_align_1: [u16; 0],
        pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::default::Default for
     pwm_channel_reg__bindgen_ty_2__bindgen_ty_1 {
        #[inline]
        fn default() -> pwm_channel_reg__bindgen_ty_2__bindgen_ty_1 {
            pwm_channel_reg__bindgen_ty_2__bindgen_ty_1{_bitfield_align_1:
                                                            ::core::default::Default::default(),
                                                        _bitfield_1:
                                                            ::core::default::Default::default(),}
        }
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::marker::Copy for pwm_channel_reg__bindgen_ty_2__bindgen_ty_1
     {
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::clone::Clone for pwm_channel_reg__bindgen_ty_2__bindgen_ty_1
     {
        #[inline]
        fn clone(&self) -> pwm_channel_reg__bindgen_ty_2__bindgen_ty_1 {
            {
                let _: ::core::clone::AssertParamIsClone<[u16; 0]>;
                let _:
                        ::core::clone::AssertParamIsClone<__BindgenBitfieldUnit<[u8; 4usize]>>;
                *self
            }
        }
    }
    impl pwm_channel_reg__bindgen_ty_2__bindgen_ty_1 {
        #[inline]
        pub fn pwm_thre1(&self) -> u32 {
            unsafe {
                ::core::mem::transmute(self._bitfield_1.get(0usize, 16u8) as
                                           u32)
            }
        }
        #[inline]
        pub fn set_pwm_thre1(&mut self, val: u32) {
            unsafe {
                let val: u32 = ::core::mem::transmute(val);
                self._bitfield_1.set(0usize, 16u8, val as u64)
            }
        }
        #[inline]
        pub fn reserved_16_31(&self) -> u32 {
            unsafe {
                ::core::mem::transmute(self._bitfield_1.get(16usize, 16u8) as
                                           u32)
            }
        }
        #[inline]
        pub fn set_reserved_16_31(&mut self, val: u32) {
            unsafe {
                let val: u32 = ::core::mem::transmute(val);
                self._bitfield_1.set(16usize, 16u8, val as u64)
            }
        }
        #[inline]
        pub fn new_bitfield_1(pwm_thre1: u32, reserved_16_31: u32)
         -> __BindgenBitfieldUnit<[u8; 4usize]> {
            let mut __bindgen_bitfield_unit:
                    __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
            __bindgen_bitfield_unit.set(0usize, 16u8,
                                        {
                                            let pwm_thre1: u32 =
                                                unsafe {
                                                    ::core::mem::transmute(pwm_thre1)
                                                };
                                            pwm_thre1 as u64
                                        });
            __bindgen_bitfield_unit.set(16usize, 16u8,
                                        {
                                            let reserved_16_31: u32 =
                                                unsafe {
                                                    ::core::mem::transmute(reserved_16_31)
                                                };
                                            reserved_16_31 as u64
                                        });
            __bindgen_bitfield_unit
        }
    }
    impl Default for pwm_channel_reg__bindgen_ty_2 {
        fn default() -> Self { unsafe { ::core::mem::zeroed() } }
    }
    #[repr(C)]
    pub union pwm_channel_reg__bindgen_ty_3 {
        pub BF: pwm_channel_reg__bindgen_ty_3__bindgen_ty_1,
        pub WORD: u32,
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::marker::Copy for pwm_channel_reg__bindgen_ty_3 { }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::clone::Clone for pwm_channel_reg__bindgen_ty_3 {
        #[inline]
        fn clone(&self) -> pwm_channel_reg__bindgen_ty_3 {
            { let _: ::core::clone::AssertParamIsCopy<Self>; *self }
        }
    }
    #[repr(C)]
    #[repr(align(4))]
    pub struct pwm_channel_reg__bindgen_ty_3__bindgen_ty_1 {
        pub _bitfield_align_1: [u16; 0],
        pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::default::Default for
     pwm_channel_reg__bindgen_ty_3__bindgen_ty_1 {
        #[inline]
        fn default() -> pwm_channel_reg__bindgen_ty_3__bindgen_ty_1 {
            pwm_channel_reg__bindgen_ty_3__bindgen_ty_1{_bitfield_align_1:
                                                            ::core::default::Default::default(),
                                                        _bitfield_1:
                                                            ::core::default::Default::default(),}
        }
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::marker::Copy for pwm_channel_reg__bindgen_ty_3__bindgen_ty_1
     {
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::clone::Clone for pwm_channel_reg__bindgen_ty_3__bindgen_ty_1
     {
        #[inline]
        fn clone(&self) -> pwm_channel_reg__bindgen_ty_3__bindgen_ty_1 {
            {
                let _: ::core::clone::AssertParamIsClone<[u16; 0]>;
                let _:
                        ::core::clone::AssertParamIsClone<__BindgenBitfieldUnit<[u8; 4usize]>>;
                *self
            }
        }
    }
    impl pwm_channel_reg__bindgen_ty_3__bindgen_ty_1 {
        #[inline]
        pub fn pwm_thre2(&self) -> u32 {
            unsafe {
                ::core::mem::transmute(self._bitfield_1.get(0usize, 16u8) as
                                           u32)
            }
        }
        #[inline]
        pub fn set_pwm_thre2(&mut self, val: u32) {
            unsafe {
                let val: u32 = ::core::mem::transmute(val);
                self._bitfield_1.set(0usize, 16u8, val as u64)
            }
        }
        #[inline]
        pub fn reserved_16_31(&self) -> u32 {
            unsafe {
                ::core::mem::transmute(self._bitfield_1.get(16usize, 16u8) as
                                           u32)
            }
        }
        #[inline]
        pub fn set_reserved_16_31(&mut self, val: u32) {
            unsafe {
                let val: u32 = ::core::mem::transmute(val);
                self._bitfield_1.set(16usize, 16u8, val as u64)
            }
        }
        #[inline]
        pub fn new_bitfield_1(pwm_thre2: u32, reserved_16_31: u32)
         -> __BindgenBitfieldUnit<[u8; 4usize]> {
            let mut __bindgen_bitfield_unit:
                    __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
            __bindgen_bitfield_unit.set(0usize, 16u8,
                                        {
                                            let pwm_thre2: u32 =
                                                unsafe {
                                                    ::core::mem::transmute(pwm_thre2)
                                                };
                                            pwm_thre2 as u64
                                        });
            __bindgen_bitfield_unit.set(16usize, 16u8,
                                        {
                                            let reserved_16_31: u32 =
                                                unsafe {
                                                    ::core::mem::transmute(reserved_16_31)
                                                };
                                            reserved_16_31 as u64
                                        });
            __bindgen_bitfield_unit
        }
    }
    impl Default for pwm_channel_reg__bindgen_ty_3 {
        fn default() -> Self { unsafe { ::core::mem::zeroed() } }
    }
    #[repr(C)]
    pub union pwm_channel_reg__bindgen_ty_4 {
        pub BF: pwm_channel_reg__bindgen_ty_4__bindgen_ty_1,
        pub WORD: u32,
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::marker::Copy for pwm_channel_reg__bindgen_ty_4 { }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::clone::Clone for pwm_channel_reg__bindgen_ty_4 {
        #[inline]
        fn clone(&self) -> pwm_channel_reg__bindgen_ty_4 {
            { let _: ::core::clone::AssertParamIsCopy<Self>; *self }
        }
    }
    #[repr(C)]
    #[repr(align(4))]
    pub struct pwm_channel_reg__bindgen_ty_4__bindgen_ty_1 {
        pub _bitfield_align_1: [u16; 0],
        pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::default::Default for
     pwm_channel_reg__bindgen_ty_4__bindgen_ty_1 {
        #[inline]
        fn default() -> pwm_channel_reg__bindgen_ty_4__bindgen_ty_1 {
            pwm_channel_reg__bindgen_ty_4__bindgen_ty_1{_bitfield_align_1:
                                                            ::core::default::Default::default(),
                                                        _bitfield_1:
                                                            ::core::default::Default::default(),}
        }
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::marker::Copy for pwm_channel_reg__bindgen_ty_4__bindgen_ty_1
     {
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::clone::Clone for pwm_channel_reg__bindgen_ty_4__bindgen_ty_1
     {
        #[inline]
        fn clone(&self) -> pwm_channel_reg__bindgen_ty_4__bindgen_ty_1 {
            {
                let _: ::core::clone::AssertParamIsClone<[u16; 0]>;
                let _:
                        ::core::clone::AssertParamIsClone<__BindgenBitfieldUnit<[u8; 4usize]>>;
                *self
            }
        }
    }
    impl pwm_channel_reg__bindgen_ty_4__bindgen_ty_1 {
        #[inline]
        pub fn pwm_period(&self) -> u32 {
            unsafe {
                ::core::mem::transmute(self._bitfield_1.get(0usize, 16u8) as
                                           u32)
            }
        }
        #[inline]
        pub fn set_pwm_period(&mut self, val: u32) {
            unsafe {
                let val: u32 = ::core::mem::transmute(val);
                self._bitfield_1.set(0usize, 16u8, val as u64)
            }
        }
        #[inline]
        pub fn reserved_16_31(&self) -> u32 {
            unsafe {
                ::core::mem::transmute(self._bitfield_1.get(16usize, 16u8) as
                                           u32)
            }
        }
        #[inline]
        pub fn set_reserved_16_31(&mut self, val: u32) {
            unsafe {
                let val: u32 = ::core::mem::transmute(val);
                self._bitfield_1.set(16usize, 16u8, val as u64)
            }
        }
        #[inline]
        pub fn new_bitfield_1(pwm_period: u32, reserved_16_31: u32)
         -> __BindgenBitfieldUnit<[u8; 4usize]> {
            let mut __bindgen_bitfield_unit:
                    __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
            __bindgen_bitfield_unit.set(0usize, 16u8,
                                        {
                                            let pwm_period: u32 =
                                                unsafe {
                                                    ::core::mem::transmute(pwm_period)
                                                };
                                            pwm_period as u64
                                        });
            __bindgen_bitfield_unit.set(16usize, 16u8,
                                        {
                                            let reserved_16_31: u32 =
                                                unsafe {
                                                    ::core::mem::transmute(reserved_16_31)
                                                };
                                            reserved_16_31 as u64
                                        });
            __bindgen_bitfield_unit
        }
    }
    impl Default for pwm_channel_reg__bindgen_ty_4 {
        fn default() -> Self { unsafe { ::core::mem::zeroed() } }
    }
    #[repr(C)]
    pub union pwm_channel_reg__bindgen_ty_5 {
        pub BF: pwm_channel_reg__bindgen_ty_5__bindgen_ty_1,
        pub WORD: u32,
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::marker::Copy for pwm_channel_reg__bindgen_ty_5 { }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::clone::Clone for pwm_channel_reg__bindgen_ty_5 {
        #[inline]
        fn clone(&self) -> pwm_channel_reg__bindgen_ty_5 {
            { let _: ::core::clone::AssertParamIsCopy<Self>; *self }
        }
    }
    #[repr(C)]
    #[repr(align(4))]
    pub struct pwm_channel_reg__bindgen_ty_5__bindgen_ty_1 {
        pub _bitfield_align_1: [u32; 0],
        pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::default::Default for
     pwm_channel_reg__bindgen_ty_5__bindgen_ty_1 {
        #[inline]
        fn default() -> pwm_channel_reg__bindgen_ty_5__bindgen_ty_1 {
            pwm_channel_reg__bindgen_ty_5__bindgen_ty_1{_bitfield_align_1:
                                                            ::core::default::Default::default(),
                                                        _bitfield_1:
                                                            ::core::default::Default::default(),}
        }
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::marker::Copy for pwm_channel_reg__bindgen_ty_5__bindgen_ty_1
     {
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::clone::Clone for pwm_channel_reg__bindgen_ty_5__bindgen_ty_1
     {
        #[inline]
        fn clone(&self) -> pwm_channel_reg__bindgen_ty_5__bindgen_ty_1 {
            {
                let _: ::core::clone::AssertParamIsClone<[u32; 0]>;
                let _:
                        ::core::clone::AssertParamIsClone<__BindgenBitfieldUnit<[u8; 4usize]>>;
                *self
            }
        }
    }
    impl pwm_channel_reg__bindgen_ty_5__bindgen_ty_1 {
        #[inline]
        pub fn reg_clk_sel(&self) -> u32 {
            unsafe {
                ::core::mem::transmute(self._bitfield_1.get(0usize, 2u8) as
                                           u32)
            }
        }
        #[inline]
        pub fn set_reg_clk_sel(&mut self, val: u32) {
            unsafe {
                let val: u32 = ::core::mem::transmute(val);
                self._bitfield_1.set(0usize, 2u8, val as u64)
            }
        }
        #[inline]
        pub fn pwm_out_inv(&self) -> u32 {
            unsafe {
                ::core::mem::transmute(self._bitfield_1.get(2usize, 1u8) as
                                           u32)
            }
        }
        #[inline]
        pub fn set_pwm_out_inv(&mut self, val: u32) {
            unsafe {
                let val: u32 = ::core::mem::transmute(val);
                self._bitfield_1.set(2usize, 1u8, val as u64)
            }
        }
        #[inline]
        pub fn pwm_stop_mode(&self) -> u32 {
            unsafe {
                ::core::mem::transmute(self._bitfield_1.get(3usize, 1u8) as
                                           u32)
            }
        }
        #[inline]
        pub fn set_pwm_stop_mode(&mut self, val: u32) {
            unsafe {
                let val: u32 = ::core::mem::transmute(val);
                self._bitfield_1.set(3usize, 1u8, val as u64)
            }
        }
        #[inline]
        pub fn pwm_sw_force_val(&self) -> u32 {
            unsafe {
                ::core::mem::transmute(self._bitfield_1.get(4usize, 1u8) as
                                           u32)
            }
        }
        #[inline]
        pub fn set_pwm_sw_force_val(&mut self, val: u32) {
            unsafe {
                let val: u32 = ::core::mem::transmute(val);
                self._bitfield_1.set(4usize, 1u8, val as u64)
            }
        }
        #[inline]
        pub fn pwm_sw_mode(&self) -> u32 {
            unsafe {
                ::core::mem::transmute(self._bitfield_1.get(5usize, 1u8) as
                                           u32)
            }
        }
        #[inline]
        pub fn set_pwm_sw_mode(&mut self, val: u32) {
            unsafe {
                let val: u32 = ::core::mem::transmute(val);
                self._bitfield_1.set(5usize, 1u8, val as u64)
            }
        }
        #[inline]
        pub fn pwm_stop_en(&self) -> u32 {
            unsafe {
                ::core::mem::transmute(self._bitfield_1.get(6usize, 1u8) as
                                           u32)
            }
        }
        #[inline]
        pub fn set_pwm_stop_en(&mut self, val: u32) {
            unsafe {
                let val: u32 = ::core::mem::transmute(val);
                self._bitfield_1.set(6usize, 1u8, val as u64)
            }
        }
        #[inline]
        pub fn pwm_sts_top(&self) -> u32 {
            unsafe {
                ::core::mem::transmute(self._bitfield_1.get(7usize, 1u8) as
                                           u32)
            }
        }
        #[inline]
        pub fn set_pwm_sts_top(&mut self, val: u32) {
            unsafe {
                let val: u32 = ::core::mem::transmute(val);
                self._bitfield_1.set(7usize, 1u8, val as u64)
            }
        }
        #[inline]
        pub fn reserved_8_31(&self) -> u32 {
            unsafe {
                ::core::mem::transmute(self._bitfield_1.get(8usize, 24u8) as
                                           u32)
            }
        }
        #[inline]
        pub fn set_reserved_8_31(&mut self, val: u32) {
            unsafe {
                let val: u32 = ::core::mem::transmute(val);
                self._bitfield_1.set(8usize, 24u8, val as u64)
            }
        }
        #[inline]
        pub fn new_bitfield_1(reg_clk_sel: u32, pwm_out_inv: u32,
                              pwm_stop_mode: u32, pwm_sw_force_val: u32,
                              pwm_sw_mode: u32, pwm_stop_en: u32,
                              pwm_sts_top: u32, reserved_8_31: u32)
         -> __BindgenBitfieldUnit<[u8; 4usize]> {
            let mut __bindgen_bitfield_unit:
                    __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
            __bindgen_bitfield_unit.set(0usize, 2u8,
                                        {
                                            let reg_clk_sel: u32 =
                                                unsafe {
                                                    ::core::mem::transmute(reg_clk_sel)
                                                };
                                            reg_clk_sel as u64
                                        });
            __bindgen_bitfield_unit.set(2usize, 1u8,
                                        {
                                            let pwm_out_inv: u32 =
                                                unsafe {
                                                    ::core::mem::transmute(pwm_out_inv)
                                                };
                                            pwm_out_inv as u64
                                        });
            __bindgen_bitfield_unit.set(3usize, 1u8,
                                        {
                                            let pwm_stop_mode: u32 =
                                                unsafe {
                                                    ::core::mem::transmute(pwm_stop_mode)
                                                };
                                            pwm_stop_mode as u64
                                        });
            __bindgen_bitfield_unit.set(4usize, 1u8,
                                        {
                                            let pwm_sw_force_val: u32 =
                                                unsafe {
                                                    ::core::mem::transmute(pwm_sw_force_val)
                                                };
                                            pwm_sw_force_val as u64
                                        });
            __bindgen_bitfield_unit.set(5usize, 1u8,
                                        {
                                            let pwm_sw_mode: u32 =
                                                unsafe {
                                                    ::core::mem::transmute(pwm_sw_mode)
                                                };
                                            pwm_sw_mode as u64
                                        });
            __bindgen_bitfield_unit.set(6usize, 1u8,
                                        {
                                            let pwm_stop_en: u32 =
                                                unsafe {
                                                    ::core::mem::transmute(pwm_stop_en)
                                                };
                                            pwm_stop_en as u64
                                        });
            __bindgen_bitfield_unit.set(7usize, 1u8,
                                        {
                                            let pwm_sts_top: u32 =
                                                unsafe {
                                                    ::core::mem::transmute(pwm_sts_top)
                                                };
                                            pwm_sts_top as u64
                                        });
            __bindgen_bitfield_unit.set(8usize, 24u8,
                                        {
                                            let reserved_8_31: u32 =
                                                unsafe {
                                                    ::core::mem::transmute(reserved_8_31)
                                                };
                                            reserved_8_31 as u64
                                        });
            __bindgen_bitfield_unit
        }
    }
    impl Default for pwm_channel_reg__bindgen_ty_5 {
        fn default() -> Self { unsafe { ::core::mem::zeroed() } }
    }
    #[repr(C)]
    pub union pwm_channel_reg__bindgen_ty_6 {
        pub BF: pwm_channel_reg__bindgen_ty_6__bindgen_ty_1,
        pub WORD: u32,
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::marker::Copy for pwm_channel_reg__bindgen_ty_6 { }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::clone::Clone for pwm_channel_reg__bindgen_ty_6 {
        #[inline]
        fn clone(&self) -> pwm_channel_reg__bindgen_ty_6 {
            { let _: ::core::clone::AssertParamIsCopy<Self>; *self }
        }
    }
    #[repr(C)]
    #[repr(align(4))]
    pub struct pwm_channel_reg__bindgen_ty_6__bindgen_ty_1 {
        pub _bitfield_align_1: [u16; 0],
        pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::default::Default for
     pwm_channel_reg__bindgen_ty_6__bindgen_ty_1 {
        #[inline]
        fn default() -> pwm_channel_reg__bindgen_ty_6__bindgen_ty_1 {
            pwm_channel_reg__bindgen_ty_6__bindgen_ty_1{_bitfield_align_1:
                                                            ::core::default::Default::default(),
                                                        _bitfield_1:
                                                            ::core::default::Default::default(),}
        }
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::marker::Copy for pwm_channel_reg__bindgen_ty_6__bindgen_ty_1
     {
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::clone::Clone for pwm_channel_reg__bindgen_ty_6__bindgen_ty_1
     {
        #[inline]
        fn clone(&self) -> pwm_channel_reg__bindgen_ty_6__bindgen_ty_1 {
            {
                let _: ::core::clone::AssertParamIsClone<[u16; 0]>;
                let _:
                        ::core::clone::AssertParamIsClone<__BindgenBitfieldUnit<[u8; 4usize]>>;
                *self
            }
        }
    }
    impl pwm_channel_reg__bindgen_ty_6__bindgen_ty_1 {
        #[inline]
        pub fn pwm_int_period_cnt(&self) -> u32 {
            unsafe {
                ::core::mem::transmute(self._bitfield_1.get(0usize, 16u8) as
                                           u32)
            }
        }
        #[inline]
        pub fn set_pwm_int_period_cnt(&mut self, val: u32) {
            unsafe {
                let val: u32 = ::core::mem::transmute(val);
                self._bitfield_1.set(0usize, 16u8, val as u64)
            }
        }
        #[inline]
        pub fn pwm_int_enable(&self) -> u32 {
            unsafe {
                ::core::mem::transmute(self._bitfield_1.get(16usize, 1u8) as
                                           u32)
            }
        }
        #[inline]
        pub fn set_pwm_int_enable(&mut self, val: u32) {
            unsafe {
                let val: u32 = ::core::mem::transmute(val);
                self._bitfield_1.set(16usize, 1u8, val as u64)
            }
        }
        #[inline]
        pub fn reserved_17_31(&self) -> u32 {
            unsafe {
                ::core::mem::transmute(self._bitfield_1.get(17usize, 15u8) as
                                           u32)
            }
        }
        #[inline]
        pub fn set_reserved_17_31(&mut self, val: u32) {
            unsafe {
                let val: u32 = ::core::mem::transmute(val);
                self._bitfield_1.set(17usize, 15u8, val as u64)
            }
        }
        #[inline]
        pub fn new_bitfield_1(pwm_int_period_cnt: u32, pwm_int_enable: u32,
                              reserved_17_31: u32)
         -> __BindgenBitfieldUnit<[u8; 4usize]> {
            let mut __bindgen_bitfield_unit:
                    __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
            __bindgen_bitfield_unit.set(0usize, 16u8,
                                        {
                                            let pwm_int_period_cnt: u32 =
                                                unsafe {
                                                    ::core::mem::transmute(pwm_int_period_cnt)
                                                };
                                            pwm_int_period_cnt as u64
                                        });
            __bindgen_bitfield_unit.set(16usize, 1u8,
                                        {
                                            let pwm_int_enable: u32 =
                                                unsafe {
                                                    ::core::mem::transmute(pwm_int_enable)
                                                };
                                            pwm_int_enable as u64
                                        });
            __bindgen_bitfield_unit.set(17usize, 15u8,
                                        {
                                            let reserved_17_31: u32 =
                                                unsafe {
                                                    ::core::mem::transmute(reserved_17_31)
                                                };
                                            reserved_17_31 as u64
                                        });
            __bindgen_bitfield_unit
        }
    }
    impl Default for pwm_channel_reg__bindgen_ty_6 {
        fn default() -> Self { unsafe { ::core::mem::zeroed() } }
    }
    impl Default for pwm_channel_reg {
        fn default() -> Self { unsafe { ::core::mem::zeroed() } }
    }
    pub type pwm_channel_reg_t = pwm_channel_reg;
    pub const BL_Err_Type_SUCCESS: BL_Err_Type = 0;
    pub const BL_Err_Type_ERROR: BL_Err_Type = 1;
    pub const BL_Err_Type_TIMEOUT: BL_Err_Type = 2;
    #[doc = " @brief Error type definition"]
    pub type BL_Err_Type = ::cty::c_uint;
    pub const BL_Mask_Type_UNMASK: BL_Mask_Type = 0;
    pub const BL_Mask_Type_MASK: BL_Mask_Type = 1;
    #[doc = " @brief Mask type definition"]
    pub type BL_Mask_Type = ::cty::c_uint;
    #[doc = "  @brief Interrupt callback function type"]
    pub type intCallback_Type =
     ::core::option::Option<unsafe extern "C" fn()>;
    #[doc = "< PWM Channel 0 define"]
    pub const PWM_CH_ID_Type_PWM_CH0: PWM_CH_ID_Type = 0;
    #[doc = "< PWM Channel 1 define"]
    pub const PWM_CH_ID_Type_PWM_CH1: PWM_CH_ID_Type = 1;
    #[doc = "< PWM Channel 2 define"]
    pub const PWM_CH_ID_Type_PWM_CH2: PWM_CH_ID_Type = 2;
    #[doc = "< PWM Channel 3 define"]
    pub const PWM_CH_ID_Type_PWM_CH3: PWM_CH_ID_Type = 3;
    #[doc = "< PWM Channel 4 define"]
    pub const PWM_CH_ID_Type_PWM_CH4: PWM_CH_ID_Type = 4;
    #[doc = "<"]
    pub const PWM_CH_ID_Type_PWM_CH_MAX: PWM_CH_ID_Type = 5;
    #[doc = "  @brief PWM No. type definition"]
    pub type PWM_CH_ID_Type = ::cty::c_uint;
    #[doc = "< PWM Clock source :XTAL CLK"]
    pub const PWM_Clk_Type_PWM_CLK_XCLK: PWM_Clk_Type = 0;
    #[doc = "< PWM Clock source :Bus CLK"]
    pub const PWM_Clk_Type_PWM_CLK_BCLK: PWM_Clk_Type = 1;
    #[doc = "< PWM Clock source :32K CLK"]
    pub const PWM_Clk_Type_PWM_CLK_32K: PWM_Clk_Type = 2;
    #[doc = "  @brief PWM Clock definition"]
    pub type PWM_Clk_Type = ::cty::c_uint;
    #[doc = "< PWM stop abrupt select define"]
    pub const PWM_Stop_Mode_Type_PWM_STOP_ABRUPT: PWM_Stop_Mode_Type = 0;
    #[doc = "< PWM stop graceful select define"]
    pub const PWM_Stop_Mode_Type_PWM_STOP_GRACEFUL: PWM_Stop_Mode_Type = 1;
    #[doc = "  @brief PWM Stop Mode definition"]
    pub type PWM_Stop_Mode_Type = ::cty::c_uint;
    #[doc = "< PWM normal polarity mode define"]
    pub const PWM_Polarity_Type_PWM_POL_NORMAL: PWM_Polarity_Type = 0;
    #[doc = "< PWM invert polarity mode define"]
    pub const PWM_Polarity_Type_PWM_POL_INVERT: PWM_Polarity_Type = 1;
    #[doc = "  @brief PWM mode type def"]
    pub type PWM_Polarity_Type = ::cty::c_uint;
    #[doc = "< PWM Pulse count interrupt define"]
    pub const PWM_INT_Type_PWM_INT_PULSE_CNT: PWM_INT_Type = 0;
    #[doc = "<"]
    pub const PWM_INT_Type_PWM_INT_ALL: PWM_INT_Type = 1;
    #[doc = "  @brief PWM interrupt type def"]
    pub type PWM_INT_Type = ::cty::c_uint;
    #[doc = "  @brief PWM configuration structure type definition"]
    #[repr(C)]
    pub struct PWM_CH_CFG_Type {
        #[doc = "< PWM channel"]
        pub ch: PWM_CH_ID_Type,
        #[doc = "< PWM Clock"]
        pub clk: PWM_Clk_Type,
        #[doc = "< PWM Stop Mode"]
        pub stopMode: PWM_Stop_Mode_Type,
        #[doc = "< PWM mode type"]
        pub pol: PWM_Polarity_Type,
        #[doc = "< PWM clkDiv num"]
        pub clkDiv: u16,
        #[doc = "< PWM period set"]
        pub period: u16,
        #[doc = "< PWM threshold1 num"]
        pub threshold1: u16,
        #[doc = "< PWM threshold2 num"]
        pub threshold2: u16,
        #[doc = "< PWM interrupt pulse count"]
        pub intPulseCnt: u16,
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::marker::Copy for PWM_CH_CFG_Type { }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::clone::Clone for PWM_CH_CFG_Type {
        #[inline]
        fn clone(&self) -> PWM_CH_CFG_Type {
            {
                let _: ::core::clone::AssertParamIsClone<PWM_CH_ID_Type>;
                let _: ::core::clone::AssertParamIsClone<PWM_Clk_Type>;
                let _: ::core::clone::AssertParamIsClone<PWM_Stop_Mode_Type>;
                let _: ::core::clone::AssertParamIsClone<PWM_Polarity_Type>;
                let _: ::core::clone::AssertParamIsClone<u16>;
                let _: ::core::clone::AssertParamIsClone<u16>;
                let _: ::core::clone::AssertParamIsClone<u16>;
                let _: ::core::clone::AssertParamIsClone<u16>;
                let _: ::core::clone::AssertParamIsClone<u16>;
                *self
            }
        }
    }
    impl Default for PWM_CH_CFG_Type {
        fn default() -> Self { unsafe { ::core::mem::zeroed() } }
    }
    extern "C" {
        pub fn PWM_Channel_Init(chCfg: *mut PWM_CH_CFG_Type)
        -> BL_Err_Type;
    }
    extern "C" {
        pub fn PWM_Channel_Update(ch: u8, period: u16, threshold1: u16,
                                  threshold2: u16);
    }
    extern "C" {
        pub fn PWM_Channel_Set_Div(ch: u8, div: u16);
    }
    extern "C" {
        pub fn PWM_Channel_Set_Threshold1(ch: u8, threshold1: u16);
    }
    extern "C" {
        pub fn PWM_Channel_Set_Threshold2(ch: u8, threshold2: u16);
    }
    extern "C" {
        pub fn PWM_Channel_Set_Period(ch: u8, period: u16);
    }
    extern "C" {
        pub fn PWM_Channel_Get(ch: u8, period: *mut u16, threshold1: *mut u16,
                               threshold2: *mut u16);
    }
    extern "C" {
        pub fn PWM_IntMask(ch: u8, intType: PWM_INT_Type,
                           intMask: BL_Mask_Type);
    }
    extern "C" {
        pub fn PWM_Channel_Enable(ch: u8);
    }
    extern "C" {
        pub fn PWM_Channel_Disable(ch: u8);
    }
    extern "C" {
        pub fn PWM_Int_Callback_Install(intType: u32,
                                        cbFun: intCallback_Type);
    }
    pub fn pwm_init(id: u8, pin: u8, freq: u32) -> BlResult<i32> {
        "----------Extern Decl----------";
        extern "C" {
            pub fn bl_pwm_init(id: u8, pin: u8, freq: u32)
            -> i32;
        }
        "----------Validation----------";
        unsafe {
            "----------Call----------";
            let res = bl_pwm_init(id as u8, pin as u8, freq as u32);
            "----------Result----------";
            Ok(res)
        }
    }
    pub fn pwm_start(id: u8) -> BlResult<i32> {
        "----------Extern Decl----------";
        extern "C" {
            pub fn bl_pwm_start(id: u8)
            -> i32;
        }
        "----------Validation----------";
        unsafe {
            "----------Call----------";
            let res = bl_pwm_start(id as u8);
            "----------Result----------";
            Ok(res)
        }
    }
    pub fn pwm_stop(id: u8) -> BlResult<i32> {
        "----------Extern Decl----------";
        extern "C" {
            pub fn bl_pwm_stop(id: u8)
            -> i32;
        }
        "----------Validation----------";
        unsafe {
            "----------Call----------";
            let res = bl_pwm_stop(id as u8);
            "----------Result----------";
            Ok(res)
        }
    }
    pub fn pwm_set_freq(id: u8, freq: u32) -> BlResult<i32> {
        "----------Extern Decl----------";
        extern "C" {
            pub fn bl_pwm_set_freq(id: u8, freq: u32)
            -> i32;
        }
        "----------Validation----------";
        unsafe {
            "----------Call----------";
            let res = bl_pwm_set_freq(id as u8, freq as u32);
            "----------Result----------";
            Ok(res)
        }
    }
    pub fn pwm_set_duty(id: u8, duty: f32) -> BlResult<i32> {
        "----------Extern Decl----------";
        extern "C" {
            pub fn bl_pwm_set_duty(id: u8, duty: f32)
            -> i32;
        }
        "----------Validation----------";
        unsafe {
            "----------Call----------";
            let res = bl_pwm_set_duty(id as u8, duty as f32);
            "----------Result----------";
            Ok(res)
        }
    }
    pub fn pwm_get_duty(id: u8, p_duty: *mut f32) -> BlResult<i32> {
        "----------Extern Decl----------";
        extern "C" {
            pub fn bl_pwm_get_duty(id: u8, p_duty: *mut f32)
            -> i32;
        }
        "----------Validation----------";
        unsafe {
            "----------Call----------";
            let res = bl_pwm_get_duty(id as u8, p_duty as *mut f32);
            "----------Result----------";
            Ok(res)
        }
    }
}
#[allow(non_camel_case_types)]
#[allow(non_snake_case)]
pub mod spi {
    use super::*;
    pub const HAL_SPI_MODE_MASTER: u32 = 1;
    pub const HAL_SPI_MODE_SLAVE: u32 = 2;
    pub type __uint8_t = ::cty::c_uchar;
    pub type __uint16_t = ::cty::c_ushort;
    pub type __int32_t = ::cty::c_int;
    pub type __uint32_t = ::cty::c_uint;
    #[repr(C)]
    pub struct spi_config_t {
        pub mode: u8,
        pub freq: u32,
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::default::Default for spi_config_t {
        #[inline]
        fn default() -> spi_config_t {
            spi_config_t{mode: ::core::default::Default::default(),
                         freq: ::core::default::Default::default(),}
        }
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::marker::Copy for spi_config_t { }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::clone::Clone for spi_config_t {
        #[inline]
        fn clone(&self) -> spi_config_t {
            {
                let _: ::core::clone::AssertParamIsClone<u8>;
                let _: ::core::clone::AssertParamIsClone<u32>;
                *self
            }
        }
    }
    #[repr(C)]
    pub struct spi_dev_t {
        pub port: u8,
        pub config: spi_config_t,
        pub priv_: *mut ::cty::c_void,
    }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::marker::Copy for spi_dev_t { }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    impl ::core::clone::Clone for spi_dev_t {
        #[inline]
        fn clone(&self) -> spi_dev_t {
            {
                let _: ::core::clone::AssertParamIsClone<u8>;
                let _: ::core::clone::AssertParamIsClone<spi_config_t>;
                let _: ::core::clone::AssertParamIsClone<*mut ::cty::c_void>;
                *self
            }
        }
    }
    impl Default for spi_dev_t {
        fn default() -> Self { unsafe { ::core::mem::zeroed() } }
    }
    extern "C" {
        #[doc = " Initialises the SPI interface for a given SPI device"]
        #[doc = ""]
        #[doc = " @param[in]  spi  the spi device"]
        #[doc = ""]
        #[doc =
          " Return:  0 : on success, EIO : if the SPI device could not be initialised"]
        pub fn hal_spi_init(spi: *mut spi_dev_t)
        -> i32;
    }
    #[doc = " Spi send"]
    #[doc = ""]
    #[doc = " @param[in]  spi      the spi device"]
    #[doc = " @param[in]  data     spi send data"]
    #[doc = " @param[in]  size     spi send data size"]
    #[doc =
      " @param[in]  timeout  timeout in milisecond, set this value to HAL_WAIT_FOREVER"]
    #[doc = "                      if you want to wait forever"]
    #[doc = ""]
    #[doc =
      " Return:  0 : on success, EIO : if the SPI device could not be initialised"]
    pub fn spi_send(spi: *mut spi_dev_t, data: *const u8, size: u16,
                    timeout: u32) -> BlResult<i32> {
        "----------Extern Decl----------";
        extern "C" {
            #[doc = " Spi send"]
            #[doc = ""]
            #[doc = " @param[in]  spi      the spi device"]
            #[doc = " @param[in]  data     spi send data"]
            #[doc = " @param[in]  size     spi send data size"]
            #[doc =
              " @param[in]  timeout  timeout in milisecond, set this value to HAL_WAIT_FOREVER"]
            #[doc = "                      if you want to wait forever"]
            #[doc = ""]
            #[doc =
              " Return:  0 : on success, EIO : if the SPI device could not be initialised"]
            pub fn hal_spi_send(spi: *mut spi_dev_t, data: *const u8,
                                size: u16, timeout: u32)
            -> i32;
        }
        "----------Validation----------";
        unsafe {
            "----------Call----------";
            let res =
                hal_spi_send(spi as *mut spi_dev_t, data as *const u8,
                             size as u16, timeout as u32);
            "----------Result----------";
            Ok(res)
        }
    }
    #[doc = " spi_recv"]
    #[doc = ""]
    #[doc = " @param[in]   spi      the spi device"]
    #[doc = " @param[out]  data     spi recv data"]
    #[doc = " @param[in]   size     spi recv data size"]
    #[doc =
      " @param[in]  timeout   timeout in milisecond, set this value to HAL_WAIT_FOREVER"]
    #[doc = "                       if you want to wait forever"]
    #[doc = ""]
    #[doc =
      " Return:  0 : on success, EIO : if the SPI device could not be initialised"]
    pub fn spi_recv(spi: *mut spi_dev_t, data: *mut u8, size: u16,
                    timeout: u32) -> BlResult<i32> {
        "----------Extern Decl----------";
        extern "C" {
            #[doc = " spi_recv"]
            #[doc = ""]
            #[doc = " @param[in]   spi      the spi device"]
            #[doc = " @param[out]  data     spi recv data"]
            #[doc = " @param[in]   size     spi recv data size"]
            #[doc =
              " @param[in]  timeout   timeout in milisecond, set this value to HAL_WAIT_FOREVER"]
            #[doc = "                       if you want to wait forever"]
            #[doc = ""]
            #[doc =
              " Return:  0 : on success, EIO : if the SPI device could not be initialised"]
            pub fn hal_spi_recv(spi: *mut spi_dev_t, data: *mut u8, size: u16,
                                timeout: u32)
            -> i32;
        }
        "----------Validation----------";
        unsafe {
            "----------Call----------";
            let res =
                hal_spi_recv(spi as *mut spi_dev_t, data as *mut u8,
                             size as u16, timeout as u32);
            "----------Result----------";
            Ok(res)
        }
    }
    #[doc = " spi send data and recv"]
    #[doc = ""]
    #[doc = " @param[in]  spi      the spi device"]
    #[doc = " @param[in]  tx_data  spi send data"]
    #[doc = " @param[in]  rx_data  spi recv data"]
    #[doc = " @param[in]  size     spi data to be sent and recived"]
    #[doc =
      " @param[in]  timeout  timeout in milisecond, set this value to HAL_WAIT_FOREVER"]
    #[doc = "                      if you want to wait forever"]
    #[doc = ""]
    #[doc =
      " Return:  0, on success;  EIO : if the SPI device could not be initialised"]
    pub fn spi_send_recv(spi: *mut spi_dev_t, tx_data: *mut u8,
                         rx_data: *mut u8, size: u16, timeout: u32)
     -> BlResult<i32> {
        "----------Extern Decl----------";
        extern "C" {
            #[doc = " spi send data and recv"]
            #[doc = ""]
            #[doc = " @param[in]  spi      the spi device"]
            #[doc = " @param[in]  tx_data  spi send data"]
            #[doc = " @param[in]  rx_data  spi recv data"]
            #[doc = " @param[in]  size     spi data to be sent and recived"]
            #[doc =
              " @param[in]  timeout  timeout in milisecond, set this value to HAL_WAIT_FOREVER"]
            #[doc = "                      if you want to wait forever"]
            #[doc = ""]
            #[doc =
              " Return:  0, on success;  EIO : if the SPI device could not be initialised"]
            pub fn hal_spi_send_recv(spi: *mut spi_dev_t, tx_data: *mut u8,
                                     rx_data: *mut u8, size: u16,
                                     timeout: u32)
            -> i32;
        }
        "----------Validation----------";
        unsafe {
            "----------Call----------";
            let res =
                hal_spi_send_recv(spi as *mut spi_dev_t, tx_data as *mut u8,
                                  rx_data as *mut u8, size as u16,
                                  timeout as u32);
            "----------Result----------";
            Ok(res)
        }
    }
    #[doc = " De-initialises a SPI interface"]
    #[doc = ""]
    #[doc = ""]
    #[doc = " @param[in]  spi the SPI device to be de-initialised"]
    #[doc = ""]
    #[doc = " Return:  0 : on success, EIO : if an error occurred"]
    pub fn spi_finalize(spi: *mut spi_dev_t) -> BlResult<i32> {
        "----------Extern Decl----------";
        extern "C" {
            #[doc = " De-initialises a SPI interface"]
            #[doc = ""]
            #[doc = ""]
            #[doc = " @param[in]  spi the SPI device to be de-initialised"]
            #[doc = ""]
            #[doc = " Return:  0 : on success, EIO : if an error occurred"]
            pub fn hal_spi_finalize(spi: *mut spi_dev_t)
            -> i32;
        }
        "----------Validation----------";
        unsafe {
            "----------Call----------";
            let res = hal_spi_finalize(spi as *mut spi_dev_t);
            "----------Result----------";
            Ok(res)
        }
    }
    pub fn spi_set_rwmode(spi_dev: *mut spi_dev_t, mode: ::cty::c_int)
     -> BlResult<()> {
        "----------Extern Decl----------";
        extern "C" {
            pub fn hal_spi_set_rwmode(spi_dev: *mut spi_dev_t,
                                      mode: ::cty::c_int)
            -> ::cty::c_int;
        }
        "----------Validation----------";
        unsafe {
            "----------Call----------";
            let res =
                hal_spi_set_rwmode(spi_dev as *mut spi_dev_t,
                                   mode as ::cty::c_int);
            "----------Result----------";
            match res { 0 => Ok(()), _ => Err(BlError::from(res)), }
        }
    }
    pub fn spi_set_rwspeed(spi_dev: *mut spi_dev_t, speed: u32)
     -> BlResult<()> {
        "----------Extern Decl----------";
        extern "C" {
            pub fn hal_spi_set_rwspeed(spi_dev: *mut spi_dev_t, speed: u32)
            -> ::cty::c_int;
        }
        "----------Validation----------";
        unsafe {
            "----------Call----------";
            let res =
                hal_spi_set_rwspeed(spi_dev as *mut spi_dev_t, speed as u32);
            "----------Result----------";
            match res { 0 => Ok(()), _ => Err(BlError::from(res)), }
        }
    }
    pub fn spi_transfer(spi_dev: *mut spi_dev_t, xfer: Ptr, size: u8)
     -> BlResult<()> {
        "----------Extern Decl----------";
        extern "C" {
            pub fn hal_spi_transfer(spi_dev: *mut spi_dev_t,
                                    xfer: *mut ::cty::c_void, size: u8)
            -> ::cty::c_int;
        }
        "----------Validation----------";
        unsafe {
            "----------Call----------";
            let res =
                hal_spi_transfer(spi_dev as *mut spi_dev_t,
                                 xfer as *mut ::cty::c_void, size as u8);
            "----------Result----------";
            match res { 0 => Ok(()), _ => Err(BlError::from(res)), }
        }
    }
    pub fn init(spi: *mut spi_dev_t, port: u8, mode: u8, polar_phase: u8,
                freq: u32, tx_dma_ch: u8, rx_dma_ch: u8, pin_clk: u8,
                pin_cs: u8, pin_mosi: u8, pin_miso: u8) -> BlResult<()> {
        "----------Extern Decl----------";
        extern "C" {
            pub fn spi_init(spi: *mut spi_dev_t, port: u8, mode: u8,
                            polar_phase: u8, freq: u32, tx_dma_ch: u8,
                            rx_dma_ch: u8, pin_clk: u8, pin_cs: u8,
                            pin_mosi: u8, pin_miso: u8)
            -> ::cty::c_int;
        }
        "----------Validation----------";
        unsafe {
            "----------Call----------";
            let res =
                spi_init(spi as *mut spi_dev_t, port as u8, mode as u8,
                         polar_phase as u8, freq as u32, tx_dma_ch as u8,
                         rx_dma_ch as u8, pin_clk as u8, pin_cs as u8,
                         pin_mosi as u8, pin_miso as u8);
            "----------Result----------";
            match res { 0 => Ok(()), _ => Err(BlError::from(res)), }
        }
    }
}
use core::{panic::PanicInfo, str::FromStr};
/// `rust_main` will be called by the BL602 command-line interface
#[no_mangle]
extern "C" fn rust_main(_buf: *const u8, _len: i32, _argc: i32,
                        _argv: *const *const u8) {
    puts("Hello from Rust!");
    const LED_GPIO: u8 = 11;
    gpio::gpio_enable_output(LED_GPIO, 0,
                             0).expect("GPIO enable output failed");
    for i in 0..10 {
        gpio::gpio_output_set(LED_GPIO, i % 2).expect("GPIO output failed");
        time_delay(time_ms_to_ticks32(1000));
    }
}
/// This function is called on panic, like an assertion failure
#[panic_handler]
fn panic(_info: &PanicInfo) -> ! { puts("TODO: Rust panic"); loop { } }
/// Print a message to the serial console.
/// TODO: Auto-generate this wrapper with `bindgen` from the C declaration
fn puts(s: &str) -> i32 {
    extern "C" {
        /// Print a message to the serial console (from C stdio library)
        fn puts(s: *const u8)
        -> i32;
    }
    let mut s_with_null =
        String::from_str(s).expect("puts conversion failed");
    s_with_null.push('\0').expect("puts overflow");
    let p = s_with_null.as_str().as_ptr();
    unsafe { puts(p) }
}
/// Convert milliseconds to system ticks.
/// TODO: Auto-generate this wrapper with `bindgen` from the C declaration:
/// `ble_npl_time_t ble_npl_time_ms_to_ticks32(uint32_t ms)`
fn time_ms_to_ticks32(ms: u32) -> u32 {
    extern "C" {
        /// Convert milliseconds to system ticks (from NimBLE Porting Layer)
        fn ble_npl_time_ms_to_ticks32(ms: u32)
        -> u32;
    }
    unsafe { ble_npl_time_ms_to_ticks32(ms) }
}
/// Sleep for the specified number of system ticks.
/// TODO: Auto-generate this wrapper with `bindgen` from the C declaration:
/// `void ble_npl_time_delay(ble_npl_time_t ticks)`
fn time_delay(ticks: u32) {
    extern "C" {
        /// Sleep for the specified number of system ticks (from NimBLE Porting Layer)
        fn ble_npl_time_delay(ticks: u32);
    }
    unsafe { ble_npl_time_delay(ticks); }
}
/// Limit Strings to 64 chars, similar to `char[64]` in C
type String = heapless::String<heapless::consts::U64>;
/// Return type and error codes for BL602 API
pub mod result {
    /// Common return type for BL602 API.  If no error, returns `Ok(val)` where val has type T.
    /// Upon error, returns `Err(err)` where err is the BlError error code.
    pub type BlResult<T> = ::core::result::Result<T, BlError>;
    /// Error codes for BL602 API
    #[repr(i32)]
    #[allow(non_camel_case_types)]
    pub enum BlError {

        /// Error code 0 means no error.
        SYS_EOK = 0,
        SYS_UNKNOWN = -1,
    }
    #[allow(non_camel_case_types)]
    impl ::core::marker::StructuralPartialEq for BlError { }
    #[automatically_derived]
    #[allow(unused_qualifications)]
    #[allow(non_camel_case_types)]
    impl ::core::cmp::PartialEq for BlError {
        #[inline]
        fn eq(&self, other: &BlError) -> bool {
            {
                let __self_vi =
                    ::core::intrinsics::discriminant_value(&*self);
                let __arg_1_vi =
                    ::core::intrinsics::discriminant_value(&*other);
                if true && __self_vi == __arg_1_vi {
                    match (&*self, &*other) { _ => true, }
                } else { false }
            }
        }
    }
    /// Cast `BlError` to `i32`
    impl From<BlError> for i32 {
        /// Cast `BlError` to `i32`
        fn from(err: BlError) -> Self { err as i32 }
    }
    /// Cast `i32` to `BlError`
    impl From<i32> for BlError {
        /// Cast `i32` to `BlError`
        fn from(num: i32) -> Self {
            unsafe { ::core::mem::transmute::<i32, BlError>(num) }
        }
    }
    /// Cast `()` to `BlError`
    impl From<()> for BlError {
        /// Cast `()` to `BlError`
        fn from(_: ()) -> Self { BlError::SYS_UNKNOWN }
    }
    /// Implement formatted output for BlError
    impl core::fmt::Debug for BlError {
        fn fmt(&self, _fmt: &mut ::core::fmt::Formatter<'_>)
         -> ::core::fmt::Result {
            Ok(())
        }
    }
}
///  Declare a `void *` pointer that will be passed to C functions
pub type Ptr = *mut ::cty::c_void;
